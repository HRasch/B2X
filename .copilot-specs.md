# GitHub Copilot Specifications for B2Connect

## Overview
This document defines guidelines and specifications for using GitHub Copilot in the B2Connect project. It ensures consistency, quality, and best practices across AI-assisted development.

## Project Context
- **Project Name**: B2Connect
- **Repository**: /Users/holger/Documents/Projekte/B2Connect
- **Structure**: Microservices-based
- **Architecture**: Multitenant SaaS Microservices Application
- **Key Characteristics**: 
  - Independent, scalable microservices
  - Complete data isolation per tenant
  - Distributed system with eventual consistency
  - API-first design pattern
- **Primary Language**: C# (.NET 8+)
- **Backend Framework**: .NET Aspire
- **Cloud Platforms**: AWS, Azure, Google Cloud (multi-cloud support)
- **Frontend Framework**: Vue.js 3 with TypeScript
- **Frontend Build Tool**: Vite
- **Frontend Package Manager**: npm or yarn

## 1. Code Generation Guidelines

### 1.1 Language & Framework Preferences
- **Primary Language**: C# (.NET 8 or later)
- **Framework**: .NET Aspire for microservices orchestration and development
- **Web Framework**: ASP.NET Core for APIs and web services
- **Data Access**: Entity Framework Core with async patterns
- **Message Broker & Mediator**: Wolverine for async messaging, CQRS, and event handling
- **Monitoring**: OpenTelemetry with Aspire dashboard integration
- **Cloud Support**: AWS (via AWS SDK), Azure (via Azure SDK), Google Cloud (via Google Cloud SDK)

### 1.2 Naming Conventions
- Use PascalCase for class names and public members
- Use camelCase for local variables and private fields (with underscore prefix: `_fieldName`)
- Use UPPER_SNAKE_CASE for constants
- Namespace hierarchy: `B2Connect.[ServiceName].[Feature]`
- File name matches class name exactly
- Interface names prefix with `I`: `IAuthenticationService`, `ITenantRepository`
- Extension method classes suffix with `Extensions`: `StringExtensions`, `EnumerableExtensions`

### 1.3 Code Organization
- One public class per file
- Maximum 500 lines per class (excepting auto-generated code)
- Single Responsibility Principle (SRP): one reason to change
- Constructor dependency injection pattern
- Group related functionality with regions (use sparingly)
- Keep using statements organized: System, external packages, internal, then aliases
- Use `#nullable enable` for nullable reference types

## 1.5 Frontend Code Generation Guidelines (Vue.js)
- Use Vue 3 Composition API with `<script setup>` syntax
- TypeScript for all Vue components and utilities
- Single File Components (SFC) with `.vue` extension
- Component naming: PascalCase (`UserForm.vue`, `TenantSelector.vue`)
- Use `ref<>()` and `reactive()` for state management
- Use `computed()` for derived state
- Use `watch()` for reactive side effects
- Prefer TypeScript interfaces over `PropType` when possible
- Async component loading with `defineAsyncComponent()`

### 1.5a Vue.js Project Structure
```
frontend/
├── src/
│   ├── components/              # Reusable components
│   │   ├── common/              # Shared across app
│   │   ├── auth/                # Auth-related components
│   │   ├── tenant/              # Tenant management components
│   │   └── [feature]/            # Feature-specific components
│   ├── views/                   # Page components (routes)
│   ├── composables/             # Reusable composition logic
│   ├── stores/                  # Pinia state management
│   ├── services/                # API clients and business logic
│   ├── types/                   # TypeScript interfaces and types
│   ├── utils/                   # Utility functions
│   ├── directives/              # Custom directives
│   ├── middleware/              # Route guards and middleware
│   ├── App.vue                  # Root component
│   └── main.ts                  # Entry point
├── tests/
│   ├── unit/                    # Unit tests with Vitest
│   ├── components/              # Component tests with Vue Test Utils
│   └── e2e/                     # End-to-end tests with Playwright
├── vite.config.ts               # Vite configuration
├── tsconfig.json                # TypeScript configuration
├── vitest.config.ts             # Vitest configuration
├── playwright.config.ts         # Playwright configuration
├── package.json                 # Dependencies and scripts
└── .env.example                 # Environment variables template
```

## 1.6 Vite Configuration & Build
- **Development Server**: Fast HMR (Hot Module Replacement)
- **Production Build**: Optimized bundles with code splitting
- **Environment Variables**: `.env`, `.env.local`, `.env.[mode]`
- **Plugin Integration**: Vue plugin, TypeScript support, auto-import
- **Code Splitting**: Lazy-load route components and large libraries
- **Build Target**: ES2020 for modern browsers
- **Source Maps**: Generate for production debugging

### 1.6a Vite Configuration Example
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueJsx from '@vitejs/plugin-vue-jsx'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    vue(),
    vueJsx(),
  ],
  resolve: {
    alias: {
      '@': resolve(__dirname, './src'),
    },
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
    },
  },
  build: {
    sourcemap: 'hidden',
    rollupOptions: {
      output: {
        manualChunks: {
          'vue': ['vue', 'vue-router', 'pinia'],
          'ui': ['primevue'],
        },
      },
    },
  },
})
```

## 1.7 Frontend State Management with Pinia
- **Store Organization**: One store per domain/feature
- **State**: Define reactive data
- **Getters**: Computed properties with dependency tracking
- **Actions**: Async operations and mutations
- **TypeScript**: Strong typing for state, getters, actions
- **Plugins**: Persist state, logging, devtools

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { User } from '@/types'
import { userApi } from '@/services/api'

export const useUserStore = defineStore('user', () => {
  const users = ref<User[]>([])
  const selectedTenantId = ref<string>('')
  const loading = ref(false)

  const filteredUsers = computed(() => 
    users.value.filter(u => u.tenantId === selectedTenantId.value)
  )

  async function fetchUsers(tenantId: string) {
    loading.value = true
    try {
      users.value = await userApi.getUsers(tenantId)
      selectedTenantId.value = tenantId
    } finally {
      loading.value = false
    }
  }

  async function createUser(user: Omit<User, 'id'>) {
    const newUser = await userApi.createUser(selectedTenantId.value, user)
    users.value.push(newUser)
    return newUser
  }

  return {
    users,
    selectedTenantId,
    loading,
    filteredUsers,
    fetchUsers,
    createUser,
  }
})
```

## 1.8 API Integration & HTTP Client
- Use Axios with interceptors for tenant context
- Configure base URL and headers
- Implement request/response interceptors for auth and errors
- Handle tenant ID propagation in all requests

```typescript
// services/api.ts
import axios from 'axios'
import type { AxiosInstance } from 'axios'
import { useAuthStore } from '@/stores/auth'
import { useTenantStore } from '@/stores/tenant'

const api: AxiosInstance = axios.create({
  baseURL: import.meta.env.VITE_API_URL || '/api',
})

// Request interceptor: Add auth token and tenant ID
api.interceptors.request.use((config) => {
  const authStore = useAuthStore()
  const tenantStore = useTenantStore()

  if (authStore.token) {
    config.headers.Authorization = `Bearer ${authStore.token}`
  }

  if (tenantStore.currentTenantId) {
    config.headers['X-Tenant-ID'] = tenantStore.currentTenantId
  }

  return config
})

// Response interceptor: Handle errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      const authStore = useAuthStore()
      authStore.logout()
    }
    return Promise.reject(error)
  }
)

export default api
```

### 1.4 Documentation Requirements
- XML documentation on all public types, methods, and properties
- Include `<summary>`, `<param>`, `<returns>`, and `<exception>` tags
- Document async behavior and cancellation token expectations
- Document tenant isolation behavior for multitenant operations
- Add inline comments only for complex logic (why, not what)
- Use TODO comments with GitHub issue references: `// TODO (#123): description`

## 2. Test-Driven Development (TDD)

### 2.1 TDD Philosophy
- **Red-Green-Refactor Cycle**:
  - **Red**: Write failing test that defines desired behavior
  - **Green**: Write minimal code to pass the test
  - **Refactor**: Improve code while keeping tests green
- **Benefits**: Better design, fewer bugs, living documentation, confidence in refactoring
- **Requirements**: Tests written BEFORE implementation code
- **Coverage Goal**: 80-90% for business logic, 100% for critical paths
- **Code Review Focus**: Verify tests were written first

### 2.2 Unit Test Pattern (xUnit + Moq)
```csharp
public class CreateUserCommandHandlerTests
{
    private readonly Mock<IUserRepository> _userRepositoryMock;
    private readonly Mock<IEmailService> _emailServiceMock;
    private readonly CreateUserCommandHandler _handler;
    private readonly Guid _tenantId = Guid.NewGuid();

    public CreateUserCommandHandlerTests()
    {
        _userRepositoryMock = new Mock<IUserRepository>();
        _emailServiceMock = new Mock<IEmailService>();
        _handler = new CreateUserCommandHandler(_userRepositoryMock.Object, _emailServiceMock.Object);
    }

    [Fact]
    public async Task Handle_WithValidUserData_CreatesUserAndSendsEmail()
    {
        // Arrange
        var command = new CreateUserCommand(_tenantId, "user@example.com", "John Doe");
        var createdUser = new User { Id = Guid.NewGuid(), Email = "user@example.com", Name = "John Doe" };
        
        _userRepositoryMock
            .Setup(r => r.CreateAsync(_tenantId, It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(createdUser);

        _emailServiceMock
            .Setup(e => e.SendWelcomeEmailAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .Returns(Task.CompletedTask);

        // Act
        var result = await _handler.Handle(command, CancellationToken.None);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(createdUser.Id, result.UserId);
        
        _userRepositoryMock.Verify(
            r => r.CreateAsync(_tenantId, It.IsAny<User>(), It.IsAny<CancellationToken>()),
            Times.Once);
        
        _emailServiceMock.Verify(
            e => e.SendWelcomeEmailAsync("user@example.com", It.IsAny<CancellationToken>()),
            Times.Once);
    }

    [Theory]
    [InlineData("")]
    [InlineData("invalid-email")]
    [InlineData(null)]
    public async Task Handle_WithInvalidEmail_ThrowsArgumentException(string invalidEmail)
    {
        // Arrange
        var command = new CreateUserCommand(_tenantId, invalidEmail, "John Doe");

        // Act & Assert
        await Assert.ThrowsAsync<ArgumentException>(() => _handler.Handle(command, CancellationToken.None));
    }

    [Fact]
    public async Task Handle_WhenEmailServiceFails_RollsBackUserCreation()
    {
        // Arrange
        var command = new CreateUserCommand(_tenantId, "user@example.com", "John Doe");
        
        _userRepositoryMock
            .Setup(r => r.CreateAsync(_tenantId, It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new User { Id = Guid.NewGuid() });

        _emailServiceMock
            .Setup(e => e.SendWelcomeEmailAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ThrowsAsync(new Exception("Email service unavailable"));

        // Act & Assert
        await Assert.ThrowsAsync<Exception>(() => _handler.Handle(command, CancellationToken.None));
        
        _userRepositoryMock.Verify(
            r => r.DeleteAsync(It.IsAny<Guid>(), It.IsAny<CancellationToken>()),
            Times.Once);
    }
}
```

## 2. Testing Specifications

### 2.1 Test Structure
- **Location**: Tests co-located with services (`services/*/tests/`)
- **Project Naming**: `[ServiceName].Tests` alongside service project
- **File Naming**: Mirror service structure; `UserService` → `UserServiceTests.cs`
- **Test Types**:
  - Unit tests: Single class/method in isolation with mocked dependencies
  - Integration tests: Service with database via TestContainers
  - Contract tests: API contract verification between services
  - End-to-end tests: Full workflow testing (separate repo/suite)

### 2.2 Test Coverage Requirements
- Minimum coverage: 80% for new code
- **Critical paths**: 100% coverage required
- **Calculation**: Lines executed / Total lines (excluding auto-generated code)
- Use `coverlet` for coverage analysis: `dotnet test /p:CollectCoverage=true /p:CoverageFormat=opencover`
- Coverage reports enforced in CI/CD pipeline
- Track coverage metrics over time in sonarqube or similar tool
- **Multitenant tests**: Must verify tenant isolation with multiple tenant contexts
- **Database tests**: Must test with actual data scenarios

### 2.3 Unit Test Organization
- One test class per class being tested: `UserRepositoryTests` for `UserRepository`
- Descriptive test method names: `MethodName_Scenario_ExpectedResult` or `Should_ExpectedBehavior_When_Condition`
- Arrange-Act-Assert (AAA) pattern religiously
- Each test tests ONE behavior only (single assertion focus)
- Use `[Fact]` for individual tests, `[Theory]` with `[InlineData]` for parameterized tests
- Test both happy path and error scenarios
- **Setup**: Use constructor for common setup; `IDisposable` for cleanup
- **Fixtures**: Shared test data via `ICollectionFixture<T>`

### 2.4 Integration Tests with TestContainers
```csharp
public class UserRepositoryIntegrationTests : IAsyncLifetime
{
    private PostgreSqlContainer _container;
    private DbContextOptions<AppDbContext> _dbContextOptions;
    private readonly Guid _tenantId = Guid.NewGuid();

    public async Task InitializeAsync()
    {
        _container = new PostgreSqlBuilder()
            .WithImage("postgres:16-alpine")
            .WithDatabase("testdb")
            .WithUsername("testuser")
            .WithPassword("testpass")
            .Build();

        await _container.StartAsync();

        var connectionString = _container.GetConnectionString();
        _dbContextOptions = new DbContextOptionsBuilder<AppDbContext>()
            .UseNpgsql(connectionString)
            .Options;

        using var context = new AppDbContext(_dbContextOptions);
        await context.Database.MigrateAsync();
    }

    public async Task DisposeAsync()
    {
        if (_container is not null)
        {
            await _container.StopAsync();
            await _container.DisposeAsync();
        }
    }

    [Fact]
    public async Task CreateAsync_WithValidUser_PersistsToDatabase()
    {
        // Arrange
        using var context = new AppDbContext(_dbContextOptions);
        var repository = new UserRepository(context);
        var user = new User { Id = Guid.NewGuid(), Email = "test@example.com", Name = "Test User" };

        // Act
        await repository.CreateAsync(_tenantId, user, CancellationToken.None);

        // Assert
        using var assertContext = new AppDbContext(_dbContextOptions);
        var savedUser = await assertContext.Users.FirstOrDefaultAsync(u => u.Email == "test@example.com");
        Assert.NotNull(savedUser);
        Assert.Equal("Test User", savedUser.Name);
    }

    [Fact]
    public async Task GetAsync_WithDifferentTenant_ReturnsNull()
    {
        // Arrange
        using var context = new AppDbContext(_dbContextOptions);
        var repository = new UserRepository(context);
        var user = new User { Id = Guid.NewGuid(), Email = "test@example.com", Name = "Test User" };
        await repository.CreateAsync(_tenantId, user, CancellationToken.None);

        var differentTenantId = Guid.NewGuid();

        // Act
        var result = await repository.GetAsync(differentTenantId, user.Id, CancellationToken.None);

        // Assert
        Assert.Null(result); // Tenant isolation verified
    }
}
```

### 2.5 Mocking Patterns with Moq
- Use `Mock<T>` for interfaces only
- Setup returns with `Setup()` and `ReturnsAsync()` for async methods
- Verify method calls: `Verify()`, `VerifyOnce()`, `VerifyNoOtherCalls()`
- Use `It.Is<>()` for complex argument matching
- Default behavior: `MockBehavior.Strict` for explicit contracts
- **Tenant Awareness**: Mock repositories must respect tenant filtering

### 2.5a Testing Wolverine Message Handlers
```csharp
public class CreateUserCommandHandlerTests
{
    private readonly Mock<IUserRepository> _userRepositoryMock;
    private readonly Mock<IMessageBus> _messageBusMock;
    private readonly CreateUserCommandHandler _handler;
    private readonly Guid _tenantId = Guid.NewGuid();

    public CreateUserCommandHandlerTests()
    {
        _userRepositoryMock = new Mock<IUserRepository>();
        _messageBusMock = new Mock<IMessageBus>();
        _handler = new CreateUserCommandHandler(_userRepositoryMock.Object, _messageBusMock.Object);
    }

    [Fact]
    public async Task Handle_WithValidUserData_CreatesUserAndPublishesEvent()
    {
        // Arrange
        var command = new CreateUserCommand(_tenantId, "user@example.com", "John Doe");
        var createdUser = new User { Id = Guid.NewGuid(), Email = "user@example.com" };
        
        _userRepositoryMock
            .Setup(r => r.CreateAsync(_tenantId, It.IsAny<User>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(createdUser);

        // Act
        var result = await _handler.Handle(command);

        // Assert
        Assert.NotNull(result);
        _userRepositoryMock.Verify(r => r.CreateAsync(_tenantId, It.IsAny<User>(), It.IsAny<CancellationToken>()), Times.Once);
        
        // Verify event was published
        _messageBusMock.Verify(
            m => m.PublishAsync(It.Is<UserCreatedEvent>(e => e.UserId == createdUser.Id && e.TenantId == _tenantId), It.IsAny<DeliveryOptions>(), It.IsAny<CancellationToken>()),
            Times.Once);
    }
}
```

### 2.5b Testing with Wolverine Test Harness
```csharp
public class CreateUserEndpointTests : IAsyncLifetime
{
    private WolverineHost _host;

    public async Task InitializeAsync()
    {
        _host = await Host.CreateDefaultBuilder()
            .UseWolverine((context, opts) =>
            {
                opts.UseInMemoryTransport();
                opts.Discovery.IncludeAssembly(typeof(CreateUserEndpoint).Assembly);
            })
            .ConfigureServices(services =>
            {
                services.AddScoped<IUserRepository, InMemoryUserRepository>();
            })
            .StartAsync();
    }

    public async Task DisposeAsync()
    {
        await _host.StopAsync();
    }

    [Fact]
    public async Task CreateUser_PublishesUserCreatedEvent()
    {
        var bus = _host.GetRuntime().Bus;
        var tenantId = Guid.NewGuid();
        var command = new CreateUserCommand(tenantId, "user@example.com", "John Doe");

        // Execute command
        await bus.InvokeAsync(command);

        // Verify event was processed
        var events = _host.GetRuntime().TrackActivity()
            .ForEvent<UserCreatedEvent>()
            .GetAll();

        Assert.NotEmpty(events);
    }
}
```

### 2.6 Test Data & Fixtures
- Use `Faker<T>` (Bogus library) for generating realistic test data
- Create fixture classes: `UserFixture`, `OrderFixture` with sensible defaults
- Fixture inheritance for variations: `ValidUserFixture : UserFixture`
- Use `Builder` pattern for complex object creation
- **Tenant Data**: Each fixture must include tenant ID
- Centralize test data in `TestFixtures` namespace

### 2.7 Async Testing
- All async tests: `public async Task` with `CancellationToken` parameter
- Use `ConfigureAwait(false)` in test code
- Mock async methods: `.ReturnsAsync(value)` or `.ThrowsAsync(exception)`
- Test cancellation scenarios: `.ThrowsAsync(new OperationCanceledException())`
- Timeout on tests: `[Fact(Timeout = 5000)]` to catch deadlocks

### 2.8 Testing Tools & Configuration
- **Framework**: xUnit v2.x
- **Mocking**: Moq v4.x
- **Assertions**: FluentAssertions v6.x
- **Test Data**: Bogus v35.x
- **Containers**: Testcontainers v3.x
- **Coverage**: Coverlet v6.x
- **Test Logger**: Serilog.Sinks.Debug for test logging

### 2.9 Frontend Testing with Vue Test Utils & Vitest
- **Unit Testing Framework**: Vitest for fast unit tests
- **Component Testing**: Vue Test Utils for Vue component testing
- **E2E Testing**: Playwright for end-to-end testing
- **Test Coverage**: Vitest with coverage reporter
- **Mocking HTTP**: MSW (Mock Service Worker) for API mocking
- **Snapshot Testing**: Use cautiously, prefer component behavior testing

```typescript
// UserForm.spec.ts - Component test with Vue Test Utils
import { describe, it, expect, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import UserForm from '@/components/UserForm.vue'
import { createPinia, setActivePinia } from 'pinia'

describe('UserForm.vue', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('renders form with email and name fields', () => {
    const wrapper = mount(UserForm, {
      props: { tenantId: 'tenant-123' },
    })

    expect(wrapper.find('input[type="email"]').exists()).toBe(true)
    expect(wrapper.find('input[type="text"]').exists()).toBe(true)
  })

  it('emits submit event with form data when submitted', async () => {
    const wrapper = mount(UserForm, {
      props: { tenantId: 'tenant-123' },
    })

    await wrapper.find('input[type="email"]').setValue('user@example.com')
    await wrapper.find('input[type="text"]').setValue('John Doe')
    await wrapper.find('form').trigger('submit')

    expect(wrapper.emitted('submit')).toBeTruthy()
    expect(wrapper.emitted('submit')[0]).toEqual([{
      email: 'user@example.com',
      name: 'John Doe',
    }])
  })

  it('shows validation errors for invalid input', async () => {
    const wrapper = mount(UserForm, {
      props: { tenantId: 'tenant-123' },
    })

    await wrapper.find('form').trigger('submit')

    expect(wrapper.text()).toContain('Email is required')
  })
})
```

### 2.10 E2E Testing with Playwright
```typescript
// tests/e2e/user-management.spec.ts
import { test, expect } from '@playwright/test'

test.describe('User Management', () => {
  test.beforeEach(async ({ page }) => {
    // Login and navigate to users page
    await page.goto('/login')
    await page.fill('input[type="email"]', 'admin@example.com')
    await page.fill('input[type="password"]', 'password')
    await page.click('button:has-text("Login")')
    await page.goto('/users')
  })

  test('should create a new user', async ({ page }) => {
    await page.click('button:has-text("Add User")')
    
    await page.fill('input[placeholder="Email"]', 'newuser@example.com')
    await page.fill('input[placeholder="Name"]', 'New User')
    await page.click('button:has-text("Create")')

    await expect(page.locator('text=newuser@example.com')).toBeVisible()
  })

  test('should filter users by tenant', async ({ page, context }) => {
    // Verify tenant isolation: user from different tenant should not be visible
    const newContext = await context.browser().newContext()
    const newPage = await newContext.newPage()
    
    // Login with different tenant and verify users are isolated
    await newPage.goto('/login')
    // ... login with different tenant
    await newPage.goto('/users')
    
    await expect(newPage.locator('text=newuser@example.com')).not.toBeVisible()
  })
})
```

## 3. Error Handling & Validation

### 3.1 Input Validation
- Validate all user inputs
- Validate API parameters before processing
- Use typed parameters when possible
- Clear error messages for validation failures
- **Tenant isolation**: Always validate tenant context and authorization

### 3.2 Error Responses
- Use consistent error object structure with standard HTTP status codes
- Include error codes, messages, and context
- Log errors with appropriate severity levels and correlation IDs
- Never expose sensitive information or internal service details
- **Distributed systems**: Include request/trace ID for debugging
- **Multitenant**: Never reveal other tenant's data in error messages

### 3.3 Exception Handling
- Use specific error types/classes
- Handle errors at appropriate levels
- Provide recovery strategies when possible
- Document expected exceptions
- **Microservices**: Implement exponential backoff for retries
- **Partial Failures**: Handle graceful degradation when dependent services are unavailable
- **Idempotency**: Ensure errors don't cause data inconsistencies on retry

## 4. Type Safety & Static Analysis

### 4.1 Type Annotations
- C# nullable reference types: Enable `#nullable enable` in all files
- Use explicit types; avoid `var` for clarity (except obvious cases)
- Use nullable (`T?`) and non-nullable (`T`) types intentionally
- Generic constraints where appropriate: `where T : class`, `where T : IEntity`
- Record types (`record class`, `record struct`) for immutable DTOs
- Use discriminated unions with sealed abstract base classes for complex types

### 4.2 Linting & Formatting
- Use EditorConfig (`.editorconfig`) for consistent formatting
- StyleCop Analyzers for C# code analysis
- Enable warning-as-error for code quality (netanalyzers)
- Use Roslyn analyzers for security issues
- Auto-format with dotnet format on pre-commit
- No warnings should remain in builds
- Enable NullableContextOptions in project files

## 5. Performance Considerations

### 5.1 Algorithm Selection
- Prefer readable solutions over premature optimization
- Document time/space complexity for critical functions
- Avoid nested loops when possible
- Use appropriate data structures (Set for lookups, etc.)
- **Distributed systems**: Consider network latency in algorithm design

### 5.2 Resource Management
- Close file handles and database connections
- Clean up event listeners and timers
- Paginate large data sets (default: 50-100 items)
- Cache computed results appropriately with TTL
- **Multitenant**: Implement per-tenant rate limiting and resource quotas
- **Connection Pooling**: Use connection pools for database access
- **Caching Strategy**: Invalidate caches when data changes across service boundaries

### 5.3 Distributed System Performance
- **Latency**: Design for acceptable response times with inter-service calls
- **Throughput**: Implement async processing for bulk operations
- **Scalability**: Design stateless services for horizontal scaling
- **Database**: Use appropriate indexes; denormalize for read-heavy scenarios
- **Monitoring**: Track SLAs per service (latency, availability)

## 6. Security Guidelines

### 6.1 Common Vulnerabilities
- Never hardcode credentials or secrets
- Use environment variables or secret management (Vault, AWS Secrets Manager)
- Validate and sanitize all inputs
- Use parameterized queries for database access
- Never expose stack traces to users
- **Tenant Isolation**: Implement and verify row-level security (RLS)
- **Cross-Tenant Access**: Audit all queries for tenant context filtering
- **API Security**: Validate tenant ownership of accessed resources

### 6.2 Dependencies
- Regularly update dependencies
- Use security audit tools (npm audit, pip audit)
- Review major version updates before upgrading
- Document why specific versions are pinned
- **Shared Dependencies**: Version shared libraries in centralized location
- **Service Communication**: Use encrypted channels (TLS) between services

### 6.3 Multitenant Security
- **Authentication**: Ensure JWT claims include tenant ID
- **Authorization**: Verify tenant context before every operation
- **Data Access**: Use parameterized queries with tenant filter
- **Segregation**: Separate database schemas, tables, or instances per tenant option
- **Secrets Management**: Isolate secrets per service and tenant
- **Audit Trail**: Log all sensitive operations with tenant context

## 7. API & Module Design

### 7.1 REST API Design
- Use ASP.NET Core Minimal APIs or Controllers based on complexity
- Use consistent URL patterns: `/api/v1/resources/{id}`
- HTTP verbs: GET (read), POST (create), PUT (update), DELETE (delete), PATCH (partial)
- Status codes: 200 (OK), 201 (Created), 204 (No Content), 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 409 (Conflict), 500 (Server Error)
- Always include tenant context in request headers (`X-Tenant-ID`) or path
- Use pagination for list endpoints: `?page=1&pageSize=50`
- Return `ProblemDetails` for errors (RFC 7231)
- Include correlation IDs in responses via headers: `X-Correlation-ID`
- Use `CancellationToken` parameter on all async endpoints
- Return `IAsyncEnumerable<T>` for streaming responses

### 7.2 Function Signatures
- Keep parameters to 3-4 maximum; use config objects for more
- Use optional parameters for non-essential values
- Export only public interfaces
- Use clear, predictable parameter ordering
- **Services**: Include tenant context as first or implicit parameter

### 7.3 Return Values
- Return consistent types with standardized structure
- Use specific types over `any` or `object`
- Prefer explicit errors over null returns
- Document side effects clearly
- **Distributed Calls**: Include metadata (timestamp, version, service name)

### 7.4 API Versioning & Compatibility
- Use URL versioning: `/api/v1/`, `/api/v2/`
- Support backward compatibility for at least 2 previous versions
- Deprecate endpoints with notice period (6+ months)
- Provide migration guides for breaking changes
- Use semantic versioning for services
- Test backward compatibility in CI/CD

## 8. Git & Version Control

### 8.1 Commit Messages
- Format: `<type>(<scope>): <subject>`
- Types: feat, fix, docs, style, refactor, test, chore
- Keep subject under 50 characters
- Reference issues: Fixes #123, Closes #456

### 8.2 Code Review
- Code generated by Copilot must be reviewed before merging
- Check for logic errors, edge cases, and security issues
- Verify test coverage
- Ensure consistency with project standards

### 8.3 Branch Naming
- Format: `feature/name`, `bugfix/name`, `docs/name`
- Use hyphens for multi-word branches
- Reference issue number: `feature/issue-123-name`

## 9. Documentation Standards

### 9.1 Inline Comments
- Explain "why", not "what" (code shows what)
- Keep comments up-to-date with code
- Remove commented-out code before committing
- Use TODO comments with context: `// TODO(user): description`

### 9.2 README Requirements
- Project description and purpose
- Installation and setup instructions
- Usage examples
- Configuration options
- Known limitations or TODOs

### 9.3 API Documentation
- Document all public endpoints/functions
- Include request/response examples
- Document error responses
- Specify version compatibility

## 10. Copilot Usage Best Practices

### 10.1 When to Use Copilot
✅ **Good uses**:
- Generating boilerplate code and service scaffolding
- Writing test cases (backend and frontend)
- Creating documentation
- Implementing well-defined functions
- Refactoring code
- API stubs and route handlers
- Vue component templates and Composition API hooks
- Vite configuration and build setup

❌ **Avoid**:
- Complex business logic without review
- Security-critical code (authentication, authorization)
- Database queries (write manually)
- API clients (write manually)
- Cross-tenant operations (high risk)
- Event handling and distributed transactions
- Data migration scripts
- Complex responsive layouts (test visually)
- State management logic requiring careful design

### 10.2 Review Process
- Read all generated code carefully
- Run tests immediately after generation (backend and frontend)
- Check for security vulnerabilities
- Verify against project standards
- **Critical for SaaS/Multitenant**: Verify tenant isolation is maintained
- Check for hardcoded tenant IDs or assumptions
- Ensure idempotency for distributed operations
- Verify proper error handling across service boundaries
- **Frontend**: Test responsive design and accessibility
- **Frontend**: Verify tenant context is passed in all API calls

### 10.3 Prompt Guidelines
- Be specific about requirements
- Reference existing code patterns
- Include constraints and edge cases
- Ask for tests alongside implementation
- **For microservices**: Specify service boundaries and dependencies
- **For multitenant**: Always mention tenant isolation requirements
- **For Vue components**: Specify props, emits, and lifecycle requirements
- **For stores**: Describe state shape and async actions

## 11. Test-Driven Development Workflow

### 11.1 TDD Process Requirements
- **Mandatory for all new features**: No feature is complete without tests written first
- **Test-First Approach**:
  1. Write failing test that captures the requirement
  2. Run test and verify it fails (Red phase)
  3. Write minimal production code to pass test (Green phase)
  4. Refactor code and tests to improve quality (Refactor phase)
  5. Repeat for next behavior
- **Definition of Done**: Feature includes tests that were written before or alongside implementation
- **Code Review Gate**: PRs without tests written first are rejected

### 11.2 TDD Benefits in Multitenant SaaS
- **Early Design**: Forces thinking about interfaces and contracts
- **Tenant Isolation Verification**: Tests prevent cross-tenant data leaks
- **Regression Prevention**: Comprehensive tests catch bugs in refactoring
- **Documentation**: Tests serve as executable specs
- **Confidence**: Deploy with certainty that critical paths work

### 11.3 Common TDD Patterns

#### Testing Repositories with Tenant Context
```csharp
[Fact]
public async Task GetByIdAsync_WithCorrectTenant_ReturnsEntity()
{
    // Write test first to define expected behavior
    var repository = new UserRepository(dbContext);
    var user = await repository.GetByIdAsync(tenantId, userId);
    Assert.NotNull(user);
}

// Then write minimal implementation:
public class UserRepository
{
    public async Task<User?> GetByIdAsync(Guid tenantId, Guid userId)
    {
        return await _context.Users
            .Where(u => u.TenantId == tenantId && u.Id == userId)
            .FirstOrDefaultAsync();
    }
}
```

#### Testing API Endpoints
```csharp
[Fact]
public async Task Post_CreateUser_ReturnsCreatedStatusWithLocation()
{
    // Arrange - test defines contract
    var request = new CreateUserRequest { Email = "new@example.com" };
    
    // Act
    var response = await _client.PostAsJsonAsync("/api/v1/users", request);
    
    // Assert - verify contract
    response.StatusCode.Should().Be(HttpStatusCode.Created);
    response.Headers.Location.Should().NotBeNull();
}
```

#### Testing Domain Logic
```csharp
[Theory]
[InlineData(0, "Quantity must be positive")]
[InlineData(-1, "Quantity must be positive")]
public void OrderItem_WithInvalidQuantity_ThrowsValidationException(int quantity, string expectedMessage)
{
    // Write test first, then implement domain logic
    var item = new OrderItem { ProductId = Guid.NewGuid() };
    
    var exception = Assert.Throws<ValidationException>(() => item.SetQuantity(quantity));
    exception.Message.Should().Contain(expectedMessage);
}
```

### 11.4 TDD Anti-Patterns to Avoid
❌ **Writing tests AFTER code** - Defeats TDD purpose
❌ **Large, complex tests** - Sign of poor design; refactor production code
❌ **Tests with multiple assertions** - Use separate tests per behavior
❌ **Brittle tests** - Tests too dependent on implementation details
❌ **Skipped tests** - Never commit tests with `[Fact(Skip = "...")]`
❌ **Interdependent tests** - Each test must be independent
❌ **Not testing error paths** - TDD includes testing exceptions

### 11.5 TDD Metrics & Monitoring
- **Test Execution Time**: Each test < 100ms (unit), integration < 1s
- **Coverage Trend**: Monitor increasing coverage over sprints
- **Test Count**: Roughly 3-5 tests per public method
- **Green Build Rate**: Target > 99% tests passing in CI
- **Flaky Tests**: Investigate and fix tests with intermittent failures

## 12. Wolverine Message Broker & Mediator Patterns

### 12.1 Wolverine Architecture Overview
- **Message-Driven Application**: Wolverine enables event-driven, loosely-coupled microservices
- **Mediator Pattern**: Built-in support for CQRS and command/event handling
- **Transport Agnostic**: Supports in-memory (dev), RabbitMQ, Azure Service Bus, AWS SQS, Google Pub/Sub
- **Zero-Trust Delivery**: Guaranteed message delivery with outbox pattern support
- **Stateful Saga Support**: Long-running processes with automatic state management

### 12.2 Message Types & Handlers

#### Commands
- Direct, synchronous, single-recipient messages
- Use for operations that need immediate feedback
- Implement `ICommandHandler<TCommand>` with return type

```csharp
// Command definition
public record CreateUserCommand(Guid TenantId, string Email, string Name) : ICommand;

// Handler
public class CreateUserCommandHandler : ICommandHandler<CreateUserCommand>
{
    private readonly IUserRepository _repository;
    private readonly IMessageBus _messageBus;

    public async Task<UserCreatedResult> Handle(CreateUserCommand command, CancellationToken ct)
    {
        var user = new User { Email = command.Email, Name = command.Name, TenantId = command.TenantId };
        await _repository.CreateAsync(command.TenantId, user, ct);
        
        // Publish domain event
        await _messageBus.PublishAsync(
            new UserCreatedEvent(command.TenantId, user.Id, command.Email),
            cancellation: ct);
        
        return new UserCreatedResult(user.Id);
    }
}
```

#### Events
- Asynchronous, broadcast messages for multiple subscribers
- Use for domain events that inform other services
- Implement `IEventHandler<TEvent>` (void return or Task)

```csharp
// Event definition
public record UserCreatedEvent(Guid TenantId, Guid UserId, string Email) : IEvent;

// Multiple handlers can subscribe to same event
public class SendWelcomeEmailEventHandler : IEventHandler<UserCreatedEvent>
{
    private readonly IEmailService _emailService;

    public async Task Handle(UserCreatedEvent @event, CancellationToken ct)
    {
        await _emailService.SendWelcomeEmailAsync(@event.Email, ct);
    }
}

public class LogUserCreationEventHandler : IEventHandler<UserCreatedEvent>
{
    private readonly ILogger<LogUserCreationEventHandler> _logger;

    public Task Handle(UserCreatedEvent @event, CancellationToken ct)
    {
        _logger.LogInformation("User {UserId} created in tenant {TenantId}", @event.UserId, @event.TenantId);
        return Task.CompletedTask;
    }
}
```

#### Scheduled Messages
- Messages scheduled for delayed or recurring execution
- Use for time-based operations (batch jobs, reminders, cleanup)

```csharp
public class CleanupExpiredSessionsCommand : ICommand;

public class CleanupExpiredSessionsHandler : ICommandHandler<CleanupExpiredSessionsCommand>
{
    public async Task Handle(CleanupExpiredSessionsCommand command, CancellationToken ct)
    {
        // Cleanup logic
    }
}

// Schedule in Startup or Endpoint
await messageBus.ScheduleAsync(
    new CleanupExpiredSessionsCommand(),
    TimeSpan.FromHours(1), // Execute in 1 hour
    cancellation: ct);

// Or recurring
await messageBus.ScheduleRecurringAsync(
    new CleanupExpiredSessionsCommand(),
    "cleanup-expired-sessions",
    schedule: "0 2 * * *"); // 2 AM daily
```

### 12.3 Tenant Context in Messages
- Always include tenant ID in messages for multitenant isolation
- Validate tenant context in handlers before processing
- Use middleware to enforce tenant context

```csharp
// Message with tenant context
public record ProcessOrderCommand(Guid TenantId, Guid OrderId, OrderDetails Details) : ICommand;

// Handler validates tenant context
public class ProcessOrderHandler : ICommandHandler<ProcessOrderCommand>
{
    private readonly IOrderRepository _repository;
    private readonly ITenantContext _tenantContext;

    public async Task Handle(ProcessOrderCommand command, CancellationToken ct)
    {
        // Verify tenant context matches message tenant
        if (_tenantContext.TenantId != command.TenantId)
        {
            throw new UnauthorizedAccessException("Tenant mismatch");
        }

        // Process with tenant isolation
        var order = await _repository.GetAsync(command.TenantId, command.OrderId, ct);
        if (order == null) throw new NotFoundException();

        // ... process order
    }
}
```

### 12.4 Error Handling & Dead Letter Queues
- Failed messages automatically moved to Dead Letter Queue (DLQ)
- Configurable retry policies per message type
- Monitor DLQ for failures and implement recovery

```csharp
// Configure in Wolverine setup
builder.Services.AddWolverine(opts =>
{
    // Retry failed commands with exponential backoff
    opts.Handlers.OnException<TransientException>()
        .Retry
        .MaximumAttempts(3)
        .WithDelayInSeconds(1, 2, 5); // Exponential backoff

    // Move permanently failed messages to DLQ
    opts.Handlers.OnException<PermanentException>()
        .MoveToDeadLetterQueue();

    // Custom handling
    opts.Handlers.OnException<SpecificException>()
        .Discard();
});
```

### 12.5 Saga Pattern for Long-Running Processes
- Orchestrate multi-step business processes across services
- Wolverine manages saga state automatically
- Implement compensating transactions for rollback

```csharp
// Saga definition
public class OrderFulfillmentSaga
{
    public Guid OrderId { get; set; }
    public Guid TenantId { get; set; }
    public OrderStatus Status { get; set; }

    // Handle order created event - start saga
    public void Start(OrderCreatedEvent @event, IMessageBus bus)
    {
        OrderId = @event.OrderId;
        TenantId = @event.TenantId;
        Status = OrderStatus.Created;
        
        bus.PublishAsync(new ReserveInventoryCommand(TenantId, OrderId, @event.Items));
    }

    // Handle inventory reserved - continue process
    public void InventoryReserved(InventoryReservedEvent @event, IMessageBus bus)
    {
        Status = OrderStatus.InventoryReserved;
        bus.PublishAsync(new ProcessPaymentCommand(TenantId, OrderId, @event.Amount));
    }

    // Handle payment confirmed - continue process
    public void PaymentProcessed(PaymentProcessedEvent @event, IMessageBus bus)
    {
        Status = OrderStatus.PaidConfirmed;
        bus.PublishAsync(new ShipOrderCommand(TenantId, OrderId));
    }

    // Handle order shipped - complete saga
    public void OrderShipped(OrderShippedEvent @event)
    {
        Status = OrderStatus.Shipped;
        MarkAsComplete();
    }
}
```

### 12.6 Testing Wolverine Handlers
- Use `WolverineHost` test harness for integration tests
- `IMessageBus` mocking for unit tests
- Verify message publish/dispatch behavior

### 12.7 Monitoring & Observability
- Wolverine integrates with OpenTelemetry for distributed tracing
- Each message includes automatic correlation ID
- Aspire dashboard shows message flow and handler latency
- Configure Serilog to capture message activity

```csharp
// Structured logging for messages
.AddSerilog()
.ConfigureLogging(logging =>
{
    logging.AddConsole();
});
```

## 13. Microservices Architecture & Cloud Integration
```
B2Connect/
├── services/
│   ├── auth-service/         # Authentication & authorization
│   │   ├── src/
│   │   ├── tests/
│   │   └── Dockerfile
│   ├── tenant-service/       # Tenant management
│   │   ├── src/
│   │   ├── tests/
│   │   └── Dockerfile
│   ├── api-gateway/          # API Gateway & routing
│   │   ├── src/
│   │   └── tests/
│   └── [other-services]/
├── shared/
│   ├── types/                # Shared TypeScript types
│   ├── utils/                # Shared utilities
│   ├── constants/            # Shared constants
│   └── middleware/           # Shared middleware
├── infrastructure/
│   ├── docker-compose.yml    # Local development
│   ├── kubernetes/           # K8s manifests
│   └── terraform/            # Infrastructure as code
├── docs/
│   ├── architecture.md       # System architecture
│   ├── api-specifications.md # API specs
│   └── tenant-isolation.md   # Multitenant design
├── frontend/                       # Vue.js + Vite SPA
│   ├── src/
│   │   ├── components/           # Reusable Vue components
│   │   ├── views/                # Page components (routes)
│   │   ├── composables/          # Reusable composition logic
│   │   ├── stores/               # Pinia state management
│   │   ├── services/             # API clients
│   │   ├── types/                # TypeScript interfaces
│   │   ├── utils/                # Utility functions
│   │   ├── middleware/           # Route guards
│   │   ├── App.vue               # Root component
│   │   └── main.ts               # Entry point
│   ├── tests/
│   │   ├── unit/                 # Unit tests (Vitest)
│   │   ├── components/           # Component tests (Vue Test Utils)
│   │   └── e2e/                  # E2E tests (Playwright)
│   ├── vite.config.ts            # Vite configuration
│   ├── tsconfig.json             # TypeScript configuration
│   ├── vitest.config.ts          # Vitest configuration
│   ├── playwright.config.ts      # Playwright configuration
│   ├── package.json              # Dependencies and scripts
│   └── .env.example              # Environment variables template
├── .copilot-specs.md         # This file
└── README.md                 # Project documentation
```

### 13.2 Frontend Technology Stack
- **Framework**: Vue.js 3 with Composition API and `<script setup>`
- **Build Tool**: Vite for fast development and optimized production builds
- **Language**: TypeScript for type safety
- **State Management**: Pinia for reactive, type-safe state
- **HTTP Client**: Axios with request/response interceptors
- **Routing**: Vue Router 4 for client-side routing
- **UI Component Library**: PrimeVue or TailwindCSS for styling
- **Form Validation**: VeeValidate for form handling
- **Testing**: Vitest (unit), Vue Test Utils (components), Playwright (E2E)

### 13.3 Environment Configuration
- Create `.env.example` with all required variables
- Never commit `.env` files
- Document all environment variables with descriptions
- Use Aspire configuration providers for environment, JSON, and secrets
- Support multiple deployment environments (dev, staging, prod)
- Environment-specific configurations for tenant isolation
- **Cloud-Specific Configurations**:
  - **AWS**: Use AWS Systems Manager Parameter Store or Secrets Manager; configure via `AddAWSOptions()`
  - **Azure**: Use Azure Key Vault and App Configuration; configure via `AddAzureKeyVault()` and `AddAzureAppConfiguration()`
  - **Google Cloud**: Use Google Cloud Secret Manager; configure via appropriate Google Cloud SDK
- Aspire secrets file (`.aspire/secrets.json`) for local development only

### 13.4 Microservice-Specific Guidelines
- **Service Boundary**: Each microservice owns its data and database
- **Communication**: Use Wolverine for async messaging and event publishing
  - Command pattern: Direct point-to-point commands
  - Event pattern: Publish-subscribe for domain events
  - Request/Reply: Synchronous request-reply with automatic timeout handling
- **Message Handlers**: Implement `ICommandHandler<>` or `IEventHandler<>` for each message type
- **Synchronous Calls**: HttpClient with Polly resilience patterns for retries and timeouts
- **Service Discovery**: Use Aspire service discovery; cloud provider-specific options (AWS ECS Service Discovery, Azure Service Fabric DNS, Google Cloud Service Directory)
- **Message Storage**: Wolverine supports in-memory, database-backed, and external transport (RabbitMQ, Azure Service Bus, AWS SQS)
- **Dead Letter Queue**: Automatic failed message handling with configurable retry policies
- **Versioning**: Version all APIs (v1, v2); support backward compatibility via Wolverine message versioning
- **Logging**: Use Serilog with structured logging; OpenTelemetry for distributed tracing
- **Monitoring**: Monitor service health, latency, error rates per tenant via Aspire dashboard and cloud provider tools
- **Health Checks**: Implement `/health` and `/health/ready` endpoints via AspNetCore.Diagnostics.HealthChecks
- **Configuration**: Use Aspire configuration orchestration; separate cloud-specific settings

### 13.5 Multitenant Requirements
- **Tenant Context**: Pass tenant ID through all request contexts
- **Data Isolation**: Implement row-level security (RLS) or separate schemas per tenant
- **Resource Quotas**: Enforce per-tenant rate limits and resource consumption
- **Audit Logging**: Log all data access and modifications with tenant context
- **Backup & Recovery**: Support per-tenant backup and recovery
- **Billing & Metering**: Track resource usage per tenant for billing
- **Shared Resources**: Identify and handle shared vs tenant-specific resources

### 13.6 SaaS-Specific Requirements
- **Authentication**: Use OpenID Connect with JWT tokens; support multi-tenant auth
- **Bearer Tokens**: Include tenant ID in JWT claims (`tid` or `tenant_id`)
- **Onboarding**: Support rapid tenant provisioning via provisioning service
- **Updates**: Support zero-downtime deployments with blue-green or canary strategies
- **Feature Flags**: Implement feature toggles per tenant/tier using feature management libraries
- **Data Retention**: Support configurable data retention policies per tenant
- **Compliance**: Support compliance requirements (GDPR, SOC2, regional data residency)
- **Scalability**: Design for horizontal scaling via Aspire deployment configurations
- **Cloud Deployment Options**:
  - **AWS**: ECS Fargate, App Runner, Lambda (for specific workloads), RDS for data
  - **Azure**: Container Instances, App Service, Azure Container Apps, Azure SQL for data
  - **Google Cloud**: Cloud Run, App Engine, Compute Engine, Cloud SQL for data
- **Cost Optimization**: Implement per-service resource limits and autoscaling policies
- **Multi-Cloud Deployment**: Abstract cloud-specific services behind interfaces for portability

## 13a. Frontend Architecture & Vue.js Best Practices

### 13a.1 Vue 3 Composition API Patterns
- Use `<script setup>` syntax for cleaner, more concise components
- Define reactive state with `ref<>()` and `reactive()`
- Compute derived state with `computed()` 
- Handle side effects with `watch()` and `watchEffect()`
- Use async/await for API calls with proper error handling
- Lifecycle hooks: `onMounted()`, `onUpdated()`, `onUnmounted()`, etc.

```typescript
// UserProfile.vue - Composition API example
<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import type { User } from '@/types'
import { userApi } from '@/services/api'

interface Props {
  userId: string
  tenantId: string
}

const props = defineProps<Props>()

const emit = defineEmits<{
  'user-updated': [user: User]
}>()

const user = ref<User | null>(null)
const loading = ref(false)
const error = ref<string | null>(null)

const userDisplay = computed(() => 
  user.value ? `${user.value.name} (${user.value.email})` : 'Unknown'
)

onMounted(async () => {
  await loadUser()
})

async function loadUser() {
  loading.value = true
  error.value = null
  try {
    user.value = await userApi.getUser(props.tenantId, props.userId)
  } catch (err) {
    error.value = err instanceof Error ? err.message : 'Failed to load user'
  } finally {
    loading.value = false
  }
}

async function updateUser(updates: Partial<User>) {
  if (!user.value) return
  
  try {
    const updated = await userApi.updateUser(props.tenantId, user.value.id, updates)
    user.value = updated
    emit('user-updated', updated)
  } catch (err) {
    error.value = err instanceof Error ? err.message : 'Failed to update user'
  }
}
</script>

<template>
  <div class="user-profile">
    <h2>{{ userDisplay }}</h2>
    
    <div v-if="loading" class="loading">Loading...</div>
    <div v-else-if="error" class="error">{{ error }}</div>
    <div v-else-if="user" class="content">
      <p>Email: {{ user.email }}</p>
      <button @click="updateUser({ lastActive: new Date() })">Update</button>
    </div>
  </div>
</template>
```

### 13a.2 Multitenant Frontend Patterns
- **Tenant Context**: Store tenant ID in Pinia store and pass to all API calls
- **Request Headers**: Axios interceptor adds `X-Tenant-ID` header automatically
- **Data Isolation**: Never mix data from different tenants
- **Permissions**: Check user permissions before rendering features
- **Routing**: Include tenant ID in route parameters or query params

```typescript
// stores/tenant.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'
import type { Tenant } from '@/types'
import { tenantApi } from '@/services/api'

export const useTenantStore = defineStore('tenant', () => {
  const currentTenant = ref<Tenant | null>(null)
  const currentTenantId = ref<string>('')
  const availableTenants = ref<Tenant[]>([])

  async function switchTenant(tenantId: string) {
    try {
      const tenant = await tenantApi.getTenant(tenantId)
      currentTenant.value = tenant
      currentTenantId.value = tenantId
      // Store in localStorage for persistence
      localStorage.setItem('currentTenantId', tenantId)
    } catch (err) {
      console.error('Failed to switch tenant:', err)
    }
  }

  async function loadAvailableTenants() {
    availableTenants.value = await tenantApi.listTenants()
  }

  return {
    currentTenant,
    currentTenantId,
    availableTenants,
    switchTenant,
    loadAvailableTenants,
  }
})
```

### 13a.3 Vite Configuration Best Practices
- Optimize chunk splitting for better caching
- Configure API proxy for development
- Setup environment variables for different deployments
- Enable source maps for production debugging
- Configure asset optimization (images, fonts)

### 13a.4 Performance Optimization
- **Code Splitting**: Lazy-load route components with `defineAsyncComponent()`
- **Bundle Analysis**: Use Vite plugin to analyze bundle size
- **Image Optimization**: Use WebP with fallback, lazy load images
- **Tree-Shaking**: Import only needed utilities
- **Composable Reuse**: Share logic across components with composables
- **Store Modules**: Organize Pinia stores by feature for better code splitting

### 13a.5 Accessibility & SEO
- Use semantic HTML (`<button>`, `<form>`, `<nav>`)
- ARIA attributes for screen readers
- Keyboard navigation support
- Color contrast compliance (WCAG AA minimum)
- Meta tags for SEO (handled by frontend framework or SSR)

## 14. Frontend-Backend Integration

### 14.1 API Integration Strategy
- **Base URL Configuration**: Use environment variables for different deployments
- **Request/Response Interceptors**: Axios interceptors for auth tokens and tenant context
- **Error Handling**: Unified error response handling across frontend
- **Retry Logic**: Automatic retries for transient failures
- **Tenant Context**: Every API request includes `X-Tenant-ID` header
- **CORS**: Configure backend CORS to allow frontend origin
- **API Versioning**: Support multiple API versions with migration strategy

### 14.2 Frontend Deployment
- **Build Process**: `npm run build` with Vite generates optimized dist folder
- **Deployment Targets**: Cloud CDN or application servers
- **Environment Configuration**: Load from `.env` files per deployment
- **Health Checks**: Frontend can check backend health before making requests
- **Feature Flags**: Load feature flags from backend per tenant
- **Offline Support**: Consider service workers for offline capability (optional)

### 14.3 Monitoring & Analytics
- **Frontend Metrics**: Track page load times, component rendering performance
- **Error Tracking**: Send frontend errors to backend logging service
- **User Analytics**: Track user interactions for tenant-specific insights
- **Performance Monitoring**: Use Web Vitals for performance tracking
- **Logging**: Structured logging with correlation IDs matching backend traces

### 14.4 Frontend npm Packages
- **Core**: `vue@3.x`, `vue-router@4.x`, `pinia@2.x`, `axios@1.x`
- **UI**: `primevue@3.x` or `tailwindcss@3.x` with `headlessui`
- **Validation**: `vee-validate@4.x` with `zod` or `yup`
- **Dev Tools**: `vite@5.x`, `vitest@1.x`, `@vue/test-utils@2.x`, `playwright@1.x`
- **Utilities**: `date-fns`, `lodash-es`, `clsx` or `classnames`
- **HTTP**: `axios@1.x` for API calls
- **State**: `pinia@2.x`, `pinia-plugin-persistedstate@2.x`

## 15. .NET Aspire & Cloud Platform Guidelines\n\n### 15.1 Aspire Project Structure
- **AppHost Project** (`*.AppHost`): Orchestrates microservices and resources (databases, message brokers)
- **ServiceDefaults Project** (`*.ServiceDefaults`): Shared configuration, health checks, OpenTelemetry setup
- **Individual Services**: Each microservice as separate project with service reference in AppHost
- **Shared Libraries**: NuGet packages for common types, utilities, and extensions
- **Cloud Deployment Manifests**: Generated manifests for AWS CloudFormation, Azure ARM templates, Google Cloud deployment configurations

### 15.2 Aspire Configuration Patterns
- Use `AddServiceDefaults()` extension method in all services
- Configure OpenTelemetry via service defaults for automatic tracing
- Implement health checks with `MapHealthChecks()` in Program.cs
- Use `AddServiceDiscovery()` for automatic service endpoint resolution
- Configure resilience via Aspire integration with Polly
- Use Aspire dashboard for local development (`dotnet run --project AppHost`)

### 15.2a Wolverine Integration with Aspire
- **Registration**: Use `AddWolverine()` in Program.cs for default in-memory messaging
- **Transport Configuration**:
  - **Development**: In-memory transport for local testing
  - **Production**: Configure external transport based on cloud platform
- **Message Handlers**: Organize in dedicated handlers folder with `ICommandHandler<T>` or `IEventHandler<T>`
- **Mediator Pattern**: Use Wolverine's built-in mediator for synchronous command handling with validation
- **Event Publishing**: Use `IMessageBus` for publishing domain events across service boundaries
- **Sagas/Orchestration**: Implement long-running processes with Wolverine's stateful handler pattern
- **Startup Messages**: Configure startup messages for service initialization (e.g., cache warming)
- **Failure Handling**: Configure dead letter queue behavior and retry policies per message type
- **Dashboard Integration**: Wolverine integrates with Aspire dashboard to show message flow and health

```csharp
// Example: Wolverine setup in Program.cs
builder.AddServiceDefaults();

builder.Services.AddWolverine(opts =>
{
    opts.Discovery.IncludeAssembly(typeof(Program).Assembly);
    
    // Configure based on environment
    if (builder.Environment.IsDevelopment())
    {
        opts.UseInMemoryTransport();
    }
    else if (builder.Environment.IsProduction())
    {
        // AWS SQS
        opts.UseAmazonSqsTransport(settings =>
        {
            settings.ConnectionString = builder.Configuration["AWS:SQS:ConnectionString"];
        });
        
        // OR Azure Service Bus
        // opts.UseAzureServiceBusTransport(builder.Configuration["Azure:ServiceBus:ConnectionString"]);
        
        // OR RabbitMQ
        // opts.UseRabbitMq(settings => 
        // {
        //     settings.ConnectionString = builder.Configuration["RabbitMQ:ConnectionString"];
        // });
    }
    
    // Configure failure handling
    opts.Handlers.OnException<ValidationException>()
        .MoveToDeadLetterQueue();
    
    opts.Handlers.OnException<TimeoutException>()
        .Retry.MaximumAttempts(3)
        .Immediately();
});
```

### 15.3 Cloud-Specific Patterns

#### AWS
- **Container Registry**: Amazon ECR for image storage
- **Container Orchestration**: ECS Fargate for container execution
- **Service Discovery**: AWS Cloud Map or ECS Service Discovery
- **Configuration**: AWS Systems Manager Parameter Store (non-secrets), Secrets Manager (secrets)
- **Message Queue**: SQS for simple messaging, SNS for pub/sub
- **Database**: RDS (PostgreSQL/SQL Server) with multi-AZ for HA
- **Monitoring**: CloudWatch for logs and metrics, X-Ray for distributed tracing
- **Load Balancing**: Application Load Balancer (ALB) with path-based routing
- **Identity**: IAM roles and policies for service-to-service authentication

#### Azure
- **Container Registry**: Azure Container Registry (ACR)
- **Container Orchestration**: Azure Container Apps for serverless containers
- **Service Discovery**: Built-in in Container Apps environment
- **Configuration**: Azure App Configuration (feature flags), Key Vault (secrets)
- **Message Queue**: Azure Service Bus for messaging and pub/sub
- **Database**: Azure SQL Database or PostgreSQL with geo-replication
- **Monitoring**: Application Insights for logs and metrics, distributed tracing built-in
- **Load Balancing**: Application Gateway or Front Door for global distribution
- **Identity**: Managed Identity for service-to-service authentication

#### Google Cloud
- **Container Registry**: Artifact Registry
- **Container Orchestration**: Cloud Run for fully managed containers
- **Service Discovery**: Cloud Service Directory or built-in Cloud Run service mesh
- **Configuration**: Secret Manager for secrets, runtime configuration via environment
- **Message Queue**: Pub/Sub for messaging and event streaming
- **Database**: Cloud SQL (PostgreSQL/MySQL/SQL Server) with high availability
- **Monitoring**: Cloud Logging and Cloud Monitoring, Cloud Trace for tracing
- **Load Balancing**: Cloud Load Balancing (HTTP/S) or Cloud CDN
- **Identity**: Service Accounts with IAM roles for authentication

### 15.4 Cross-Cloud Abstraction
- Create interfaces for cloud-specific services: `IStorageService`, `IMessageBroker`, `ISecretProvider`
- Implement platform-specific providers (AwsStorageService, AzureStorageService, GoogleCloudStorageService)
- Use dependency injection to select implementation per deployment environment
- Keep business logic independent of cloud provider
- Use standard .NET abstractions (e.g., `IConfiguration`, `ILogger`) for portability

### 15.5 Dependency Management
- Use Central Package Management (`Directory.Packages.props`) for version alignment
- Pin to specific versions; avoid wildcards in service projects
- Regular dependency updates via Dependabot with security alerts
- **Core Packages**:
  - `Wolverine` - Message broker, CQRS, event handling
  - `Wolverine.Http` - HTTP transport for Wolverine (optional)
  - `Wolverine.RabbitMQ` - RabbitMQ transport (if using RabbitMQ)
  - `Wolverine.AzureServiceBus` - Azure Service Bus transport (if using Azure)
  - `Wolverine.AmazonSqs` - AWS SQS transport (if using AWS)
  - `Serilog`, `Serilog.Sinks.Console`, `Serilog.Enrichers.Environment` - Structured logging
  - `OpenTelemetry.*` - Observability
  - `Polly` - Resilience patterns
  - `FluentValidation` - Input validation
- **Cloud SDKs**:
  - **AWS**: `AWSSDK.Core`, `AWSSDK.SecretsManager`, `AWSSDK.SimpleSystemsManagement`, `AWSSDK.SQS`
  - **Azure**: `Azure.Identity`, `Azure.Security.KeyVault.Secrets`, `Azure.Data.AppConfiguration`, `Azure.Messaging.ServiceBus`
  - **Google Cloud**: `Google.Cloud.Secrets.V1`, `Google.Cloud.SecretManager.V1`, `Google.Cloud.PubSub.V1`

## 16. Review Checklist for Copilot-Generated Code

Before merging any Copilot-generated code, verify:

- [ ] Code follows C# naming conventions (PascalCase, camelCase, underscore prefix)
- [ ] XML documentation on all public types/methods
- [ ] Nullable reference types enabled and correct
- [ ] Error handling returns ProblemDetails for APIs
- [ ] No hardcoded values or secrets (use configuration)
- [ ] Tests are included and passing (xUnit format)
- [ ] Test coverage meets minimum (80%)
- [ ] Async/await used correctly with ConfigureAwait(false)
- [ ] Performance is acceptable
- [ ] Security issues addressed (parameterized queries, input validation)
- [ ] Consistent with existing codebase style
- [ ] Commit message follows conventions
- [ ] No external NuGet dependencies added without discussion
- [ ] **Multitenant checks**: Tenant context properly handled
- [ ] **Multitenant checks**: Tenant ID filtering on all queries
- [ ] **Multitenant checks**: No cross-tenant data exposure
- [ ] **Microservice checks**: Service boundary respected
- [ ] **Microservice checks**: No direct database access between services
- [ ] **Microservice checks**: Proper error handling for service failures
- [ ] **Microservice checks**: Idempotency ensured for retries
- [ ] **Aspire checks**: ServiceDefaults properly configured
- [ ] **Aspire checks**: Health checks implemented
- [ ] **Cloud checks**: Cloud-specific implementation abstracted behind interfaces
- [ ] **Cloud checks**: Configuration sourced from environment/vault (not hardcoded)
- [ ] **Frontend checks**: Vue components use Composition API with proper TypeScript
- [ ] **Frontend checks**: Pinia stores properly configured with getters and actions
- [ ] **Frontend checks**: API calls include tenant context (X-Tenant-ID header)
- [ ] **Frontend checks**: Error handling displays user-friendly messages
- [ ] **Frontend checks**: Responsive design tested on mobile/tablet/desktop
- [ ] **Frontend checks**: Accessibility standards met (WCAG AA minimum)
- [ ] **Frontend checks**: Unit tests cover component logic and composables
- [ ] **Frontend checks**: No hardcoded API URLs (use environment variables)
- [ ] **Frontend checks**: Vite build optimized (code splitting, tree-shaking)

## 18. Internationalization & Localization (i18n)

### 18.1 Supported Languages
- **Default Language**: English (en)
- **Supported Languages**: 
  - German (de-DE)
  - French (fr-FR)
  - Spanish (es-ES)
  - Italian (it-IT)
  - Portuguese (pt-BR)
  - Dutch (nl-NL)
  - Polish (pl-PL)
  - Additional languages: Expandable via configuration
- **Fallback**: English when requested language unavailable

### 18.2 Backend Localization (C# / .NET)

#### 18.2a Localization Architecture
- Create dedicated `LocalizationService` per microservice or shared across platform
- Use **IStringLocalizer** interface for compile-time key validation
- Store translations in database (`LocalizationDbContext`) for runtime updates
- Implement **language detection middleware** with priority rules
- Support **tenant-specific translation overrides**

#### 18.2b Translation Database Model
```csharp
// Models/LocalizedString.cs
public class LocalizedString
{
    public Guid Id { get; set; }
    public string Key { get; set; }
    public string Category { get; set; }
    public Dictionary<string, string> Translations { get; set; }
    public string DefaultValue { get; set; }
    public Guid? TenantId { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

// DbContext
public class LocalizationDbContext : DbContext
{
    public DbSet<LocalizedString> LocalizedStrings { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<LocalizedString>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.HasIndex(e => new { e.Key, e.Category }).IsUnique();
            entity.HasIndex(e => e.TenantId);
        });
    }
}
```

#### 18.2c ILocalizationService Interface
```csharp
// Services/ILocalizationService.cs
public interface ILocalizationService
{
    Task<string> GetStringAsync(string key, string category, CancellationToken cancellationToken = default);
    Task<string> GetStringAsync(string key, string category, string language, CancellationToken cancellationToken = default);
    Task<Dictionary<string, string>> GetCategoryAsync(string category, string language, CancellationToken cancellationToken = default);
    Task<IEnumerable<string>> GetSupportedLanguagesAsync(CancellationToken cancellationToken = default);
    Task SetStringAsync(Guid? tenantId, string key, string category, Dictionary<string, string> translations, CancellationToken cancellationToken = default);
    string GetCurrentLanguage();
}
```

#### 18.2d Language Detection Middleware
```csharp
// Middleware/LocalizationMiddleware.cs
public class LocalizationMiddleware
{
    private readonly RequestDelegate _next;
    private const string DEFAULT_LANGUAGE = "en";

    public LocalizationMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Priority: 1. Query, 2. Header, 3. Cookie, 4. Default
        var language = 
            context.Request.Query["lang"].FirstOrDefault() ??
            context.Request.Headers["Accept-Language"].FirstOrDefault() ??
            context.Request.Cookies["locale"] ??
            DEFAULT_LANGUAGE;

        language = language.Substring(0, 2).ToLower();
        
        CultureInfo.CurrentCulture = new CultureInfo(language);
        CultureInfo.CurrentUICulture = new CultureInfo(language);
        context.Items["Language"] = language;
        context.Response.Headers["Content-Language"] = language;

        await _next(context);
    }
}

// Program.cs: Register middleware BEFORE routing
app.UseMiddleware<LocalizationMiddleware>();
```

#### 18.2e Localization Service Implementation
```csharp
// Services/LocalizationService.cs
public class LocalizationService : ILocalizationService
{
    private readonly LocalizationDbContext _context;
    private readonly IMemoryCache _cache;
    private readonly IHttpContextAccessor _httpContextAccessor;
    private const string CACHE_PREFIX = "i18n:";

    public LocalizationService(
        LocalizationDbContext context,
        IMemoryCache cache,
        IHttpContextAccessor httpContextAccessor)
    {
        _context = context;
        _cache = cache;
        _httpContextAccessor = httpContextAccessor;
    }

    public string GetCurrentLanguage()
    {
        var context = _httpContextAccessor.HttpContext;
        return context?.Items["Language"] as string ?? "en";
    }

    public async Task<string> GetStringAsync(string key, string category, CancellationToken cancellationToken = default)
    {
        var language = GetCurrentLanguage();
        return await GetStringAsync(key, category, language, cancellationToken);
    }

    public async Task<string> GetStringAsync(string key, string category, string language, CancellationToken cancellationToken = default)
    {
        var cacheKey = $"{CACHE_PREFIX}{category}:{key}:{language}";
        
        if (_cache.TryGetValue(cacheKey, out var cachedValue))
            return (string)cachedValue;

        var localized = await _context.LocalizedStrings
            .AsNoTracking()
            .FirstOrDefaultAsync(ls => ls.Key == key && ls.Category == category, cancellationToken);

        if (localized?.Translations.TryGetValue(language, out var value) == true)
        {
            _cache.Set(cacheKey, value, TimeSpan.FromHours(1));
            return value;
        }

        // Fallback to English
        if (localized?.Translations.TryGetValue("en", out var fallback) == true)
            return fallback;

        return localized?.DefaultValue ?? $"[{category}.{key}]";
    }

    public async Task<Dictionary<string, string>> GetCategoryAsync(string category, string language, CancellationToken cancellationToken = default)
    {
        var cacheKey = $"{CACHE_PREFIX}{category}:{language}";
        
        if (_cache.TryGetValue(cacheKey, out var cachedDict))
            return (Dictionary<string, string>)cachedDict;

        var strings = await _context.LocalizedStrings
            .AsNoTracking()
            .Where(ls => ls.Category == category)
            .ToListAsync(cancellationToken);

        var result = new Dictionary<string, string>();
        foreach (var localized in strings)
        {
            result[localized.Key] = localized.Translations.TryGetValue(language, out var val) 
                ? val 
                : localized.DefaultValue;
        }

        _cache.Set(cacheKey, result, TimeSpan.FromHours(1));
        return result;
    }

    public Task<IEnumerable<string>> GetSupportedLanguagesAsync(CancellationToken cancellationToken = default)
    {
        return Task.FromResult((IEnumerable<string>)new[] { "en", "de", "fr", "es", "it", "pt", "nl", "pl" });
    }

    public async Task SetStringAsync(Guid? tenantId, string key, string category, Dictionary<string, string> translations, CancellationToken cancellationToken = default)
    {
        var existing = await _context.LocalizedStrings
            .FirstOrDefaultAsync(ls => ls.Key == key && ls.Category == category && ls.TenantId == tenantId, cancellationToken);

        if (existing == null)
        {
            existing = new LocalizedString 
            { 
                Key = key, 
                Category = category, 
                TenantId = tenantId,
                DefaultValue = translations.GetValueOrDefault("en", key),
                CreatedAt = DateTime.UtcNow
            };
            _context.LocalizedStrings.Add(existing);
        }

        existing.Translations = translations;
        existing.UpdatedAt = DateTime.UtcNow;
        
        await _context.SaveChangesAsync(cancellationToken);
        InvalidateCache(category);
    }

    private void InvalidateCache(string category)
    {
        // Cache invalidation - remove related keys from memory cache
    }
}
```

#### 18.2f Localization Controller
```csharp
// Controllers/LocalizationController.cs
[ApiController]
[Route("api/localization")]
public class LocalizationController : ControllerBase
{
    private readonly ILocalizationService _localizationService;

    public LocalizationController(ILocalizationService localizationService)
    {
        _localizationService = localizationService;
    }

    /// <summary>Get translated string by key and category</summary>
    [HttpGet("{category}/{key}")]
    public async Task<IActionResult> GetString(string category, string key, [FromQuery] string language = "en", CancellationToken cancellationToken = default)
    {
        var value = await _localizationService.GetStringAsync(key, category, language, cancellationToken);
        return Ok(new { key = $"{category}.{key}", value, language });
    }

    /// <summary>Get all translations for a category</summary>
    [HttpGet("category/{category}")]
    public async Task<IActionResult> GetCategory(string category, [FromQuery] string language = "en", CancellationToken cancellationToken = default)
    {
        var translations = await _localizationService.GetCategoryAsync(category, language, cancellationToken);
        return Ok(new { category, language, translations });
    }

    /// <summary>Get supported languages</summary>
    [HttpGet("languages")]
    public async Task<IActionResult> GetLanguages(CancellationToken cancellationToken = default)
    {
        var languages = await _localizationService.GetSupportedLanguagesAsync(cancellationToken);
        return Ok(new { languages });
    }

    /// <summary>Set/update translations (Admin only)</summary>
    [HttpPost("{category}/{key}")]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> SetString(string category, string key, [FromBody] Dictionary<string, string> translations, CancellationToken cancellationToken = default)
    {
        var tenantId = User.FindFirst("tenant")?.Value != null ? Guid.Parse(User.FindFirst("tenant").Value) : null;
        await _localizationService.SetStringAsync(tenantId, key, category, translations, cancellationToken);
        return NoContent();
    }
}
```

### 18.3 Frontend Localization (Vue.js)

#### 18.3a vue-i18n Setup
```typescript
// locales/index.ts
import { createI18n } from 'vue-i18n'
import type { I18n } from 'vue-i18n'
import en from './en.json'
import de from './de.json'
import fr from './fr.json'

export const i18n: I18n = createI18n({
  legacy: false,
  locale: localStorage.getItem('locale') || 'en',
  fallbackLocale: 'en',
  messages: { en, de, fr },
})

export default i18n
```

#### 18.3b Translation JSON Files
```json
// locales/en.json
{
  "auth": { "login": "Login", "logout": "Logout" },
  "ui": { "save": "Save", "cancel": "Cancel", "delete": "Delete" },
  "errors": { "required": "Required", "invalid_email": "Invalid email" }
}

// locales/de.json
{
  "auth": { "login": "Anmelden", "logout": "Abmelden" },
  "ui": { "save": "Speichern", "cancel": "Abbrechen", "delete": "Löschen" },
  "errors": { "required": "Erforderlich", "invalid_email": "Ungültige E-Mail" }
}
```

#### 18.3c Vue Component Usage
```vue
<!-- components/LanguageSwitcher.vue -->
<template>
  <select @change="setLocale" :value="locale">
    <option value="en">English</option>
    <option value="de">Deutsch</option>
    <option value="fr">Français</option>
  </select>
</template>

<script setup lang="ts">
import { useI18n } from 'vue-i18n'
import { useAuthStore } from '@/stores/auth'

const { locale } = useI18n()
const authStore = useAuthStore()

const setLocale = async (event: Event) => {
  const newLocale = (event.target as HTMLSelectElement).value
  locale.value = newLocale
  localStorage.setItem('locale', newLocale)
  if (authStore.user) {
    await authStore.updateLanguagePreference(newLocale)
  }
}
</script>
```

### 18.4 Database Seeding
```csharp
// Data/LocalizationSeeder.cs
public static class LocalizationSeeder
{
    public static async Task SeedAsync(LocalizationDbContext context)
    {
        if (await context.LocalizedStrings.AnyAsync())
            return;

        var strings = new[]
        {
            new LocalizedString
            {
                Key = "login",
                Category = "auth",
                DefaultValue = "Login",
                Translations = new() { { "en", "Login" }, { "de", "Anmelden" }, { "fr", "Connexion" } },
            },
            new LocalizedString
            {
                Key = "required",
                Category = "errors",
                DefaultValue = "This field is required",
                Translations = new() 
                { 
                    { "en", "This field is required" }, 
                    { "de", "Dieses Feld ist erforderlich" },
                    { "fr", "Ce champ est obligatoire" },
                },
            },
        };

        await context.LocalizedStrings.AddRangeAsync(strings);
        await context.SaveChangesAsync();
    }
}
```

### 18.5 Testing
```csharp
// Tests/LocalizationServiceTests.cs
[Fact]
public async Task GetStringAsync_ReturnsTranslationForLanguage()
{
    // Arrange
    var localized = new LocalizedString
    {
        Key = "title", Category = "auth", DefaultValue = "Login",
        Translations = new() { { "en", "Login" }, { "de", "Anmelden" } },
    };
    _context.LocalizedStrings.Add(localized);
    await _context.SaveChangesAsync();

    // Act
    var result = await _service.GetStringAsync("title", "auth", "de");

    // Assert
    Assert.Equal("Anmelden", result);
}

[Fact]
public async Task GetStringAsync_FallsBackToEnglish_WhenLanguageUnsupported()
{
    // Arrange
    var localized = new LocalizedString
    {
        Key = "title", Category = "auth", DefaultValue = "Login",
        Translations = new() { { "en", "Login" } },
    };
    _context.LocalizedStrings.Add(localized);
    await _context.SaveChangesAsync();

    // Act
    var result = await _service.GetStringAsync("title", "auth", "xx");

    // Assert
    Assert.Equal("Login", result);
}
```

### 18.6 Tenant-Specific Overrides
- Store tenant ID in translation queries: `tenantId != null` takes precedence
- Allow admins to customize translations per tenant
- Fall back to global translations if no tenant override exists

### 18.7 Best Practices
- Keep translation keys lowercase with dots: `auth.login.title`
- Group related keys by category: `auth.*`, `ui.*`, `errors.*`
- Always provide English fallback
- Cache translations (1 hour TTL) to avoid database hits
- Load language from: query param → header → cookie → default
- Version translations in database with `UpdatedAt` timestamp
- Test with RTL languages (Arabic, Hebrew) if planning expansion

---

## 19. Requirements Clarification & Problem Detection

### 19.1 Understanding Assessment
When receiving a requirement or task, ALWAYS assess for:

**A) Clarity Issues**
- ❓ Unclear or ambiguous terms (define precisely)
- ❓ Missing context or assumptions
- ❓ Undefined edge cases or error handling
- ❓ Unspecified performance or scalability requirements
- ❓ Missing tenant isolation or security considerations
- ❓ Conflicting with existing code patterns

**B) Technical Feasibility**
- ❓ Does it align with current architecture?
- ❓ Are there conflicting requirements?
- ❓ Are dependencies available/compatible?
- ❓ Will it impact existing functionality?
- ❓ Is the timeline realistic given complexity?

**C) Alternative Solutions**
- ✨ Better approach (simpler, more performant, more maintainable)?
- ✨ Existing patterns/libraries that solve this problem?
- ✨ Refactoring needed to support the requirement cleanly?
- ✨ Could this be split into smaller, clearer tasks?
- ✨ Is there a proven pattern in the codebase to follow?

### 19.2 When to Ask for Clarification

**ASK IMMEDIATELY if you encounter:**

```
"I need a search feature"
❓ Where? (ProductSearch in CatalogService? GlobalSearch in ApiGateway?)
❓ How? (Elasticsearch integration? Simple LINQ? Full-text search?)
❓ What fields? (Only name? Category? Price range?)
❓ Performance requirements? (Sub-100ms? 1-second acceptable?)
❓ How many documents? (Hundreds? Millions?)
❓ Tenant isolation? (Separate index per tenant? Shared with filtering?)
```

```
"Add validation to the API"
❓ What validation rules? (Email format? Length constraints? Business rules?)
❓ Which fields? (All input fields? Specific ones?)
❓ Error responses? (Return first error? All errors? Detailed messages?)
❓ Existing validation pattern? (Fluent validation? Annotations? Custom?)
❓ Tenant-specific rules? (Different validation per tenant?)
```

```
"Improve performance"
❓ Which operation is slow? (Specific endpoint? Database query?)
❓ What's the bottleneck? (Database? API? Network?)
❓ Current vs. target metrics? (10 seconds → 1 second? 100ms → 50ms?)
❓ Load scenario? (10 users? 1000 concurrent users?)
❓ Acceptable trade-offs? (Memory usage? Code complexity? Caching?)
```

### 19.3 Suggested Refactoring / Alternative Approaches

**IF I IDENTIFY a better solution, I will propose:**

1. **State the Problem** - What issue did I identify?
   - Example: "The proposed approach creates N+1 queries to the database"

2. **Show the Alternative** - What's the better way?
   - Example: "Use a JOIN query with Entity Framework's `Include()` method"

3. **Compare Trade-offs** - What are the pros/cons?
   - Better: Simpler code, 90% fewer queries, better performance
   - Trade-off: Slightly more complex LINQ, need to handle circular references

4. **Ask Permission** - Should we proceed with this approach?
   - ✅ "Should I refactor to use this pattern?"
   - ✅ "Would you prefer the simpler approach with slight performance trade-off?"
   - ✅ "Should we split this into two tasks: refactoring + feature?"

### 19.4 Common Clarity Gaps & Questions

| Requirement Type | What I'll Ask | Why It Matters |
|-----------------|---------------|----------------|
| **New API Endpoint** | Input/output format? Auth required? Tenant-scoped? Rate limits? | API design clarity, security, multi-tenancy |
| **Database Query** | Scale (how many records)? Filter criteria? Sorting? Pagination? | Query performance, index needs, memory usage |
| **UI Component** | Desktop/mobile? Responsive breakpoints? Accessibility requirements? Translations? | Design consistency, UX quality, accessibility |
| **Event-Driven Feature** | When exactly is the event published? What if it fails? Retry logic? | Data consistency, eventual consistency model |
| **Background Job** | Frequency? Timeout? Failure handling? Monitoring? | System reliability, observability |
| **Caching Strategy** | Cache key? TTL? Invalidation logic? Race conditions? | Cache correctness, performance, consistency |
| **Multi-tenant Feature** | Tenant isolation strategy? Data visibility? Admin overrides? | Security, data isolation, compliance |

### 19.5 Proactive Problem Detection

**I will flag these potential issues:**

✅ **Architecture Concerns**
- "This feature might violate the single responsibility principle"
- "This creates a circular dependency between services"
- "This bypasses our standard tenant isolation pattern"

✅ **Performance Risks**
- "This query could N+1 on large datasets"
- "Loading all records into memory isn't scalable"
- "This synchronous operation could timeout under load"

✅ **Security Issues**
- "Missing input validation on this endpoint"
- "This query doesn't filter by tenant ID"
- "SQL injection risk without parameterized queries"

✅ **Data Consistency**
- "Event ordering could cause data inconsistency"
- "Cache invalidation might create stale data"
- "Eventual consistency could cause user confusion"

✅ **Code Quality**
- "This duplicates logic already in [OtherService]"
- "This could be simplified using [Pattern] from [ExistingCode]"
- "This violates the [Pattern] established in [File]"

### 19.6 Decision Framework

**When I identify issues, I will follow this process:**

```
1. UNDERSTAND THE REQUIREMENT
   ↓
2. ASSESS FOR CLARITY
   ├─ Clear? → Proceed with implementation
   └─ Unclear? → Ask clarifying questions (19.2)
   
3. CHECK FEASIBILITY
   ├─ Feasible? → Check for alternatives
   └─ Not feasible? → Propose alternative approach
   
4. EVALUATE ALTERNATIVES
   ├─ Better approach exists? → Propose with trade-off analysis (19.3)
   └─ Current approach is best? → Proceed
   
5. ASK PERMISSION
   ├─ "Should I implement with this approach?"
   ├─ "Should we refactor first?"
   └─ "Should we adjust the requirement?"
   
6. IMPLEMENT WHEN APPROVED
   └─ Follow all specs in this document
```

### 19.7 Real-World Example

**User Request**: "Add a feature to bulk import products"

**My Response**:
```
I can implement bulk product import. Before I start, I need to clarify:

CLARITY QUESTIONS:
1. What's the file format? (CSV? JSON? Excel?)
2. Max file size? (1MB? 100MB? 1GB?)
3. What happens with invalid rows? (Skip? Reject whole import? Mark as warning?)
4. Success notification? (Email? UI toast? Webhook?)

TECHNICAL OBSERVATIONS:
1. I see ProductCreatedEvent exists - should we use that for each imported product?
2. Background job needed? Bulk import could take time (Hangfire integration?)
3. Partial failure handling - rollback everything or process what's valid?

SUGGESTED APPROACH:
Instead of importing all at once, I'd suggest:
- Upload file → queue background job
- Process in batches (prevent memory overflow)
- Store import progress (user can check status)
- Return error report (which rows failed and why)

BENEFITS:
- Handles large files gracefully (100MB+ possible)
- Non-blocking (fast response, process in background)
- Better UX (user sees progress, error details)

TRADE-OFFS:
- Slightly more complex (background job orchestration)
- Not instant (async instead of sync)

NEXT STEPS:
1. What file format do you need?
2. What's acceptable file size?
3. Should we use the approach above, or do you prefer synchronous import?
4. Any specific error handling requirements?
```

---

## 17. Escalation & Exceptions

### When to Deviate
- Security-critical functionality: Always code manually
- Performance-critical sections: Benchmark before accepting generated code
- Complex algorithms: Consider manual implementation
- Project-specific patterns: May need custom rules

### Getting Help
- Reference existing code in prompts
- Break complex tasks into smaller pieces
- Use git history to understand patterns
- Discuss complex changes in PRs before implementation

---

**Document Version**: 1.2
**Last Updated**: 2025-12-25
**Maintainer**: B2Connect Team
**Latest Changes**: Added Requirements Clarification & Problem Detection (Section 19)

---

## 20. AOP (Aspect Oriented Programming) Patterns

### 20.1 Purpose & Benefits
Aspect-Oriented Programming separates cross-cutting concerns from business logic:
- **Logging & Diagnostics**: Centralized request/response logging
- **Validation**: Input validation via FluentValidation
- **Error Handling**: Consistent exception handling and transformations
- **Authorization**: Role-based and permission checks
- **Performance Monitoring**: Method execution timing and metrics
- **Caching**: Transparent caching strategies
- **Transactional Integrity**: ACID compliance without boilerplate

### 20.2 Implementation Approach

#### 20.2.1 Interceptors (Castle.DynamicProxy or Scrutor)
Use Castle.DynamicProxy with dependency injection for method interception:

```csharp
public interface IAsyncInterceptor
{
    Task InterceptAsync(IInvocation invocation);
}

public class LoggingInterceptor : IAsyncInterceptor
{
    private readonly ILogger<LoggingInterceptor> _logger;

    public async Task InterceptAsync(IInvocation invocation)
    {
        _logger.LogInformation("Executing: {Method}", invocation.Method.Name);
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            await invocation.ReturnValue as Task ?? Task.CompletedTask;
        }
        finally
        {
            stopwatch.Stop();
            _logger.LogInformation("Completed: {Method} ({Duration}ms)", 
                invocation.Method.Name, stopwatch.ElapsedMilliseconds);
        }
    }
}
```

#### 20.2.2 Action Filters (Attribute-based)
Use attribute-based filters for controller-level AOP:

```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class ValidateModelAttribute : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        if (!context.ModelState.IsValid)
        {
            context.Result = new BadRequestObjectResult(
                new { errors = context.ModelState.Values.SelectMany(v => v.Errors) }
            );
        }
    }
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]
public class ExceptionHandlingAttribute : ExceptionFilterAttribute
{
    private readonly ILogger<ExceptionHandlingAttribute> _logger;

    public override void OnException(ExceptionContext context)
    {
        _logger.LogError(context.Exception, "Unhandled exception");
        context.Result = new ObjectResult(
            new { error = context.Exception.Message }
        ) { StatusCode = StatusCodes.Status500InternalServerError };
    }
}
```

#### 20.2.3 Middleware (Pipeline-level)
For global concerns that affect all requests:

```csharp
public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger;

    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var originalBodyStream = context.Response.Body;
        using (var responseBody = new MemoryStream())
        {
            context.Response.Body = responseBody;
            
            _logger.LogInformation("HTTP {Method} {Path}", context.Request.Method, context.Request.Path);
            await _next(context);
            
            _logger.LogInformation("HTTP {StatusCode}", context.Response.StatusCode);
            await responseBody.CopyToAsync(originalBodyStream);
        }
    }
}
```

### 20.3 Controller Pattern with AOP

Controllers should be clean and focused on routing/response formatting:

```csharp
[ApiController]
[Route("api/[controller]")]
[ValidateModel]  // AOP: automatic model validation
[ExceptionHandling]  // AOP: centralized error handling
public class ProductsController : ControllerBase
{
    private readonly IProductService _service;

    public ProductsController(IProductService service)
    {
        _service = service;
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<ProductDto>> GetProduct(Guid id)
    {
        // Validation is handled by AOP (FluentValidation)
        // Error handling is done by AOP
        var product = await _service.GetProductAsync(id);
        return Ok(product);
    }

    [HttpPost]
    public async Task<ActionResult<ProductDto>> CreateProduct([FromBody] CreateProductRequest request)
    {
        // Request validation via FluentValidation + AOP
        var product = await _service.CreateProductAsync(request);
        return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, product);
    }
}
```

---

## 21. FluentValidation Integration

### 21.1 Purpose
FluentValidation provides:
- Declarative, expressive validation rules
- Rule chaining and complex conditions
- Automatic model state population
- Integration with MVC/API validation pipeline
- Async validation support (e.g., database lookups)
- Localized error messages

### 21.2 Implementation

#### 21.2.1 Define Request DTOs

```csharp
public record CreateProductRequest(
    string Sku,
    string Name,
    string Description,
    decimal Price,
    int StockQuantity,
    string[] Tags,
    Dictionary<string, LocalizedContent> LocalizedNames
);
```

#### 21.2.2 Create Validators

```csharp
public class CreateProductRequestValidator : AbstractValidator<CreateProductRequest>
{
    private readonly IProductRepository _repository;

    public CreateProductRequestValidator(IProductRepository repository)
    {
        _repository = repository;

        RuleFor(x => x.Sku)
            .NotEmpty().WithMessage("SKU is required")
            .Length(3, 50).WithMessage("SKU must be between 3 and 50 characters")
            .Matches(@"^[A-Z0-9-]+$").WithMessage("SKU must contain only uppercase letters, numbers, and hyphens")
            .MustAsync(async (sku, ct) => !await _repository.SkuExistsAsync(sku, ct))
                .WithMessage("SKU '{PropertyValue}' already exists");

        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Product name is required")
            .Length(2, 200).WithMessage("Product name must be between 2 and 200 characters");

        RuleFor(x => x.Price)
            .GreaterThan(0).WithMessage("Price must be greater than 0")
            .Must(x => decimal.Round(x, 2) == x).WithMessage("Price can have maximum 2 decimal places");

        RuleFor(x => x.StockQuantity)
            .GreaterThanOrEqualTo(0).WithMessage("Stock quantity cannot be negative");

        RuleFor(x => x.LocalizedNames)
            .NotEmpty().WithMessage("At least one localized name is required")
            .Must(x => x.ContainsKey("en")).WithMessage("English (en) localized name is required");
    }
}
```

#### 21.2.3 Register Validators

In `Program.cs`:

```csharp
// FluentValidation integration
services.AddValidatorsFromAssembly(typeof(Program).Assembly);

// Auto-register all validators
services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));

// Alternative: Manual registration
services.AddScoped<IValidator<CreateProductRequest>, CreateProductRequestValidator>();
```

#### 21.2.4 Validation Behavior Middleware

```csharp
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;
    private readonly ILogger<ValidationBehavior<TRequest, TResponse>> _logger;

    public ValidationBehavior(
        IEnumerable<IValidator<TRequest>> validators,
        ILogger<ValidationBehavior<TRequest, TResponse>> logger)
    {
        _validators = validators;
        _logger = logger;
    }

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var validationFailures = new List<ValidationFailure>();

        foreach (var validator in _validators)
        {
            var validationResult = await validator.ValidateAsync(request, cancellationToken);
            if (!validationResult.IsValid)
            {
                _logger.LogWarning("Validation failed for {RequestType}: {Errors}",
                    typeof(TRequest).Name,
                    string.Join("; ", validationResult.Errors.Select(e => e.ErrorMessage)));
                
                validationFailures.AddRange(validationResult.Errors);
            }
        }

        if (validationFailures.Any())
        {
            throw new ValidationException(validationFailures);
        }

        return await next();
    }
}
```

### 21.3 Controller Integration Example

```csharp
[HttpPost]
[ValidateFluentModel]  // AOP attribute for FluentValidation
public async Task<ActionResult<ProductDto>> CreateProduct(
    [FromBody] CreateProductRequest request)
{
    // At this point, request is guaranteed to be valid
    var product = await _service.CreateProductAsync(request);
    return CreatedAtAction(nameof(GetProduct), new { id = product.Id }, product);
}
```

### 21.4 Error Response Format

Standardized error response:

```csharp
public record ValidationErrorResponse(
    string Status,
    string Message,
    Dictionary<string, string[]> Errors,
    DateTime Timestamp
);
```

Example response:
```json
{
    "status": "ValidationFailed",
    "message": "One or more validation errors occurred",
    "errors": {
        "Sku": ["SKU already exists"],
        "Price": ["Price must be greater than 0"]
    },
    "timestamp": "2025-12-26T10:30:00Z"
}
```

---

## 22. Domain Event Validation with FluentValidation

### 22.1 Purpose & Benefits

Validating domain events before publishing ensures:
- **Data Consistency**: Events contain only valid, complete data
- **Early Error Detection**: Catch invalid events before message broker processing
- **System Reliability**: Prevent downstream errors in event handlers
- **Audit Trail**: Validation errors are logged for diagnostics
- **Type Safety**: Strongly-typed validators with compile-time checking
- **Reusability**: Validator rules defined once, used everywhere

### 22.2 Base Event Validator

All events inherit from `DomainEvent`, so create a base validator:

```csharp
// File: backend/shared/validators/EventValidators.cs
using FluentValidation;
using B2Connect.Types;

public abstract class DomainEventValidator<TEvent> : AbstractValidator<TEvent>
    where TEvent : DomainEvent
{
    protected DomainEventValidator()
    {
        // Common rules for all events
        RuleFor(e => e.EventId)
            .NotEmpty()
            .WithMessage("EventId must not be empty");

        RuleFor(e => e.Timestamp)
            .NotEqual(default(DateTime))
            .LessThanOrEqualTo(DateTime.UtcNow.AddSeconds(1))
            .WithMessage("Timestamp cannot be in the future");

        RuleFor(e => e.AggregateId)
            .NotEqual(Guid.Empty)
            .WithMessage("AggregateId must not be empty");

        RuleFor(e => e.AggregateType)
            .NotEmpty()
            .MaximumLength(100)
            .WithMessage("AggregateType must be valid");

        RuleFor(e => e.EventType)
            .NotEmpty()
            .Matches(@"^[a-z]+(\.[a-z]+)*$")
            .WithMessage("EventType must use lowercase dot notation (e.g., 'product.created')");

        RuleFor(e => e.Version)
            .GreaterThan(0)
            .WithMessage("Version must be greater than 0");
    }
}
```

### 22.3 Event-Specific Validators

Create service-specific validators:

```csharp
// File: backend/services/CatalogService/src/Validators/EventValidators.cs
public class ProductCreatedEventValidator : AbstractValidator<ProductCreatedEvent>
{
    public ProductCreatedEventValidator()
    {
        // Base properties
        RuleFor(e => e.EventId).NotEmpty();
        RuleFor(e => e.Timestamp).LessThanOrEqualTo(DateTime.UtcNow.AddSeconds(1));
        
        // Product-specific validation
        RuleFor(e => e.ProductId)
            .NotEqual(Guid.Empty)
            .WithMessage("ProductId must not be empty");

        RuleFor(e => e.Sku)
            .NotEmpty()
            .Length(3, 50)
            .Matches(@"^[A-Z0-9\-]+$")
            .WithMessage("SKU must be 3-50 uppercase chars, numbers, and hyphens");

        RuleFor(e => e.Name)
            .NotEmpty()
            .MaximumLength(255)
            .WithMessage("Product name is required and max 255 chars");

        RuleFor(e => e.Price)
            .GreaterThan(0)
            .Must(p => decimal.Round(p, 2) == p)
            .WithMessage("Price must be positive with max 2 decimal places");

        RuleFor(e => e.B2bPrice)
            .Null()
            .Or(p => p
                .LessThanOrEqualTo(e => e.Price)
                .WithMessage("B2B price cannot exceed regular price"));

        RuleFor(e => e.Tags)
            .Must(t => t.Length <= 20)
            .WithMessage("Maximum 20 tags allowed")
            .ForEach(tag => tag
                .NotEmpty()
                .MaximumLength(50));

        RuleFor(e => e.ImageUrls)
            .Must(urls => urls.Length <= 10)
            .ForEach(url => url
                .Must(u => Uri.TryCreate(u, UriKind.Absolute, out _))
                .WithMessage("Each image URL must be a valid absolute URI"));

        RuleFor(e => e.TenantId)
            .NotEqual(Guid.Empty)
            .WithMessage("TenantId must not be empty");
    }
}
```

### 22.4 Event Validation Service

Implement validation interceptor:

```csharp
// File: backend/shared/aop/EventValidationInterceptor.cs
public interface IEventValidationService
{
    Task<(bool IsValid, List<string> Errors)> ValidateEventAsync(DomainEvent @event);
    Task PublishValidatedEventAsync<T>(T @event) where T : DomainEvent;
}

public class EventValidationService : IEventValidationService
{
    private readonly EventValidatorFactory _validatorFactory;
    private readonly ILogger<EventValidationService> _logger;

    public async Task<(bool IsValid, List<string> Errors)> ValidateEventAsync(DomainEvent @event)
    {
        var result = await _validatorFactory.ValidateEventWithResultAsync(@event);
        
        if (!result.IsValid)
        {
            var errors = result.Errors.Select(e => e.ErrorMessage).ToList();
            _logger.LogWarning(
                "Event validation failed for {EventType} (Id: {EventId})",
                @event.EventType, @event.EventId);
            return (false, errors);
        }

        _logger.LogInformation(
            "Event validation succeeded for {EventType} (Id: {EventId})",
            @event.EventType, @event.EventId);
        return (true, new List<string>());
    }

    public async Task PublishValidatedEventAsync<T>(T @event) where T : DomainEvent
    {
        var (isValid, errors) = await ValidateEventAsync(@event);
        if (!isValid)
        {
            throw new InvalidOperationException(
                $"Event validation failed: {string.Join("; ", errors)}");
        }
    }
}
```

### 22.5 Event Publisher with Validation

```csharp
public interface IEventPublisher
{
    Task PublishAsync<T>(T @event) where T : DomainEvent;
}

public class ValidatedEventPublisher : IEventPublisher
{
    private readonly IEventValidationService _validationService;
    private readonly ILogger<ValidatedEventPublisher> _logger;

    public async Task PublishAsync<T>(T @event) where T : DomainEvent
    {
        await _validationService.PublishValidatedEventAsync(@event);
        _logger.LogInformation(
            "Published validated event {EventType} (Id: {EventId})",
            @event.EventType, @event.EventId);
    }
}
```

### 22.6 Integration in Services

```csharp
public class ProductService
{
    private readonly IEventPublisher _eventPublisher;

    public async Task CreateProductAsync(CreateProductRequest request)
    {
        // Create product in repository
        var product = await _repository.CreateAsync(request);
        
        // Create and publish event (automatically validated)
        var @event = new ProductCreatedEvent(
            ProductId: product.Id,
            Sku: product.Sku,
            Name: product.Name,
            Description: request.Description,
            Category: request.Category,
            Price: product.Price,
            B2bPrice: request.B2bPrice,
            StockQuantity: request.StockQuantity,
            Tags: request.Tags,
            Attributes: request.Attributes,
            ImageUrls: request.ImageUrls,
            TenantId: _tenantContext.TenantId);

        // Publish - validation happens automatically
        await _eventPublisher.PublishAsync(@event);
    }
}
```

### 22.7 Setup in Program.cs

```csharp
// Register event validation
builder.Services.AddEventValidation(typeof(Program));

// Or as part of full AOP setup
builder.Services.AddAopAndValidation(typeof(Program));

// Use middleware
app.UseEventValidation();
```

### 22.8 Testing Event Validators

```csharp
[Fact]
public async Task ProductCreatedEventValidator_WithValidData_Succeeds()
{
    var @event = new ProductCreatedEvent(
        ProductId: Guid.NewGuid(),
        Sku: "TEST-001",
        Name: "Test Product",
        Price: 99.99m,
        B2bPrice: null,
        StockQuantity: 100,
        Tags: new[] { "test" },
        Attributes: new ProductAttributesDto(),
        ImageUrls: new[] { "https://example.com/image.jpg" },
        TenantId: Guid.NewGuid());

    var result = await validator.ValidateAsync(@event);
    
    Assert.True(result.IsValid);
}

[Fact]
public async Task ProductCreatedEventValidator_WithInvalidSku_Fails()
{
    var @event = new ProductCreatedEvent(
        ProductId: Guid.NewGuid(),
        Sku: "invalid",  // Should be uppercase
        Name: "Test Product",
        Price: 99.99m,
        B2bPrice: null,
        StockQuantity: 100,
        Tags: new[] { "test" },
        Attributes: new ProductAttributesDto(),
        ImageUrls: new[] { "https://example.com/image.jpg" },
        TenantId: Guid.NewGuid());

    var result = await validator.ValidateAsync(@event);
    
    Assert.False(result.IsValid);
    Assert.Contains(result.Errors, e => e.PropertyName == "Sku");
}
```

### 22.9 Error Handling

When event validation fails:

```csharp
try
{
    await _eventPublisher.PublishAsync(@event);
}
catch (InvalidOperationException ex)
{
    // Log validation error
    _logger.LogError("Event publication failed: {Message}", ex.Message);
    
    // Option 1: Return error to client
    return BadRequest(new { error = ex.Message });
    
    // Option 2: Add to dead letter queue
    await _deadLetterQueue.EnqueueAsync(@event, ex.Message);
    
    // Option 3: Retry with exponential backoff
    await _retryPolicy.ExecuteAsync(() => _eventPublisher.PublishAsync(@event));
}
```

### 22.10 Best Practices

**DO:**
- Validate events before any side effects occur
- Use meaningful error messages for debugging
- Log validation failures with event context
- Test both valid and invalid scenarios
- Inherit from base validators for consistency
- Use async validators for database checks (e.g., SKU uniqueness)

**DON'T:**
- Skip event validation to improve performance
- Allow invalid events through error handling
- Duplicate validation logic between requests and events
- Publish events directly without ValidatedEventPublisher
- Suppress validation errors silently

### 22.11 EventValidator Factory

```csharp
public class EventValidatorFactory
{
    private readonly IValidator<DomainEvent>[] _validators;

    public async Task<bool> ValidateEventAsync(DomainEvent @event)
    {
        foreach (var validator in _validators)
        {
            var result = await validator.ValidateAsync(@event);
            if (!result.IsValid) return false;
        }
        return true;
    }

    public async Task<ValidationResult> ValidateEventWithResultAsync(DomainEvent @event)
    {
        var errors = new List<ValidationFailure>();
        foreach (var validator in _validators)
        {
            var result = await validator.ValidateAsync(@event);
            if (!result.IsValid) errors.AddRange(result.Errors);
        }
        return new ValidationResult(errors.Count == 0, errors);
    }
}
```

---

**Document Version**: 1.4
**Last Updated**: 2025-12-26
**Maintainer**: B2Connect Team
**Latest Changes**: Added Domain Event Validation (Section 22)

