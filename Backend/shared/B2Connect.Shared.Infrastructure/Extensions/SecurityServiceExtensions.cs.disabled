using B2Connect.Shared.Infrastructure.Authentication.Passkeys;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Caching.StackExchangeRedis;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using StackExchange.Redis;
using System.Text;
using EFCore.NamingConventions;

namespace B2Connect.Shared.Infrastructure.Extensions;

/// <summary>
/// Service Extensions für Passkeys, Secret Store und PostgreSQL Integration
/// </summary>
public static class AuthenticationServiceExtensions
{
    /// <summary>
    /// Registriert Passkeys (FIDO2/WebAuthn) Authentifizierung
    /// </summary>
    public static IServiceCollection AddPasskeysAuthentication(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        if (!bool.Parse(configuration["Auth:Passkeys:Enabled"] ?? "false"))
        {
            return services;
        }

        services.AddScoped<IPasskeysService, PasskeysService>();

        services.Configure<PasskeysOptions>(configuration.GetSection("Auth:Passkeys"));

        return services;
    }

    /// <summary>
    /// Registriert Azure Key Vault für Secrets Management
    /// </summary>
    public static IServiceCollection AddAzureKeyVaultSecrets(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var keyVaultUri = configuration["Azure:KeyVault:Uri"];

        if (string.IsNullOrEmpty(keyVaultUri))
        {
            return services; // Skip if not configured
        }

        // In production: Add Azure.Security.KeyVault.Secrets nuget
        // builder.Configuration.AddAzureKeyVault(
        //     new Uri(keyVaultUri),
        //     new DefaultAzureCredential());

        return services;
    }

    /// <summary>
    /// Konfiguriert PostgreSQL für Entity Framework
    /// </summary>
    public static IServiceCollection AddPostgresqlDbContext<TContext>(
        this IServiceCollection services,
        IConfiguration configuration,
        string connectionStringKey = "DefaultConnection")
        where TContext : DbContext
    {
        var connectionString = configuration.GetConnectionString(connectionStringKey);

        if (string.IsNullOrEmpty(connectionString))
        {
            if (configuration["ASPNETCORE_ENVIRONMENT"] == "Development")
            {
                connectionString = "Host=localhost;Database=b2connect;Username=postgres;Password=postgres;";
            }
            else
            {
                throw new InvalidOperationException(
                    $"Connection string '{connectionStringKey}' not found. " +
                    "Configure via ConnectionStrings or environment variables.");
            }
        }

        services.AddDbContext<TContext>(options =>
            options
                .UseNpgsql(connectionString, npgsql =>
                {
                    npgsql.EnableRetryOnFailure(
                        maxRetryCount: 3,
                        maxRetryDelaySeconds: 30,
                        errorCodesToAdd: null);
                    npgsql.CommandTimeout(30);
                    npgsql.UseAdminDatabase();
                })
                .UseSnakeCaseNamingConvention()
        );

        return services;
    }

    /// <summary>
    /// Konfiguriert Redis Cache mit Encryption
    /// </summary>
    public static IServiceCollection AddRedisCache(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var redisConnection = configuration.GetConnectionString("Redis")
            ?? configuration["Redis:Connection"]
            ?? "localhost:6379";

        var options = ConfigurationOptions.Parse(redisConnection);
        options.AbortOnConnectFail = false;
        options.ConnectTimeout = 5000;
        options.SyncTimeout = 5000;

        var connection = ConnectionMultiplexer.Connect(options);

        services.AddSingleton(connection);
        services.AddStackExchangeRedisCache(cacheOptions =>
        {
            cacheOptions.ConnectionMultiplexerFactory = () => Task.FromResult(connection);
            cacheOptions.Configuration = redisConnection;
        });

        return services;
    }

    /// <summary>
    /// Konfiguriert Token Cache für Distributed Caching
    /// </summary>
    public static IServiceCollection AddDistributedTokenCache(
        this IServiceCollection services)
    {
        services.AddScoped<IDistributedCache>(provider =>
        {
            var cache = provider.GetRequiredService<IDistributedCache>();
            return new DistributedCacheWrapper(cache);
        });

        return services;
    }

    /// <summary>
    /// Konfiguriert alle Security-relevanten Services
    /// </summary>
    public static IServiceCollection AddB2ConnectSecurity(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Passkeys
        services.AddPasskeysAuthentication(configuration);

        // Azure Key Vault
        services.AddAzureKeyVaultSecrets(configuration);

        // Redis Cache
        services.AddRedisCache(configuration);

        // Distributed Cache for Tokens
        services.AddDistributedTokenCache();

        // JWT mit Passkeys
        var jwtSecret = configuration["Jwt:Secret"];
        if (string.IsNullOrEmpty(jwtSecret))
        {
            throw new InvalidOperationException(
                "JWT Secret MUST be configured. Set 'Jwt:Secret' via environment variables or Azure Key Vault.");
        }

        services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options =>
            {
                options.TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidateIssuerSigningKey = true,
                    ValidIssuer = configuration["Jwt:Issuer"] ?? "B2Connect",
                    ValidAudience = configuration["Jwt:Audience"] ?? "B2Connect",
                    IssuerSigningKey = new SymmetricSecurityKey(
                        Encoding.UTF8.GetBytes(jwtSecret)),
                    ClockSkew = TimeSpan.FromSeconds(60),
                };

                // Support for Passkeys: No password validation needed
                if (bool.Parse(configuration["Jwt:UsePasskeys"] ?? "false"))
                {
                    options.Events = new JwtBearerEvents
                    {
                        OnTokenValidated = context =>
                        {
                            // Passkey-based tokens are already verified by WebAuthn
                            return Task.CompletedTask;
                        },
                        OnMessageReceived = context =>
                        {
                            // Extract token from bearer scheme
                            return Task.CompletedTask;
                        },
                    };
                }
            });

        return services;
    }
}

/// <summary>
/// Optionen für Passkeys Konfiguration
/// </summary>
public class PasskeysOptions
{
    public bool Enabled { get; set; }
    public RelyingPartyOptions RP { get; set; } = new();
    public string AttestationConveyance { get; set; } = "none";
    public string UserVerification { get; set; } = "preferred";
    public AuthenticatorSelectionOptions AuthenticatorSelection { get; set; } = new();
    public int ChallengeTimeout { get; set; } = 60000;
}

public class RelyingPartyOptions
{
    public string Name { get; set; } = "B2Connect";
    public string Origin { get; set; } = "https://localhost:5174";
}

public class AuthenticatorSelectionOptions
{
    public bool Resident { get; set; } = true;
    public string AuthenticatorAttachment { get; set; } = "platform";
}

/// <summary>
/// Wrapper für Distributed Cache mit Encryption Support
/// </summary>
public class DistributedCacheWrapper : IDistributedCache
{
    private readonly IDistributedCache _cache;

    public DistributedCacheWrapper(IDistributedCache cache)
    {
        _cache = cache;
    }

    public byte[]? Get(string key)
    {
        return _cache.Get(key);
    }

    public async Task<byte[]?> GetAsync(string key, CancellationToken token = default)
    {
        return await _cache.GetAsync(key, token);
    }

    public void Set(string key, byte[] value, DistributedCacheEntryOptions? options = null)
    {
        // TODO: Add encryption for sensitive data
        _cache.Set(key, value, options);
    }

    public async Task SetAsync(string key, byte[] value, DistributedCacheEntryOptions? options = null,
        CancellationToken token = default)
    {
        // TODO: Add encryption for sensitive data
        await _cache.SetAsync(key, value, options, token);
    }

    public void Refresh(string key)
    {
        _cache.Refresh(key);
    }

    public async Task RefreshAsync(string key, CancellationToken token = default)
    {
        await _cache.RefreshAsync(key, token);
    }

    public void Remove(string key)
    {
        _cache.Remove(key);
    }

    public async Task RemoveAsync(string key, CancellationToken token = default)
    {
        await _cache.RemoveAsync(key, token);
    }
}
